<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title><%= title %></title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #e8f4f8, #d1e9f5);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .header {
            width: 100%;
            background: linear-gradient(135deg, #4a90e2, #67a6e5);
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            width: 100%;
            max-width: 408px;
            padding: 0 15px 15px;
            box-sizing: border-box;
            gap: 15px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            color: white;
            flex: 1;
            max-width: 120px;
            font-weight: 500;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-new {
            background: linear-gradient(135deg, #34ace0, #63cdff);
        }

        .btn-exit {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .btn-solve {
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
        }

        .stats {
            background-color: white;
            padding: 15px 30px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.1);
            margin: 0 0 20px;
            display: flex;
            gap: 40px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8fa6;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
        }

        .container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
            gap: 20px;
        }

        #game, #mirror-maze {
            width: 100%;
            max-width: 520px;
            height: 520px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.15);
            padding: 25px;
            box-sizing: border-box;
            position: relative;
            overflow: visible;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .maze-piece {
            position: absolute;
            width: 90px;
            height: 90px;
            background: white;
            z-index: 0;
            margin: 2px;
        }

        #drawing-board {
            width: 408px;
            height: 408px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            cursor: crosshair;
        }

        .game_item {
            position: absolute;
            z-index: 2;
            border-radius: 0;
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
            color: white;
            text-align: center;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            transition: transform 0.2s ease;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game_item:empty {
            background: transparent;
            box-shadow: none;
            pointer-events: none;
            opacity: 0;
        }

        .game_item {
            z-index: 3;
        }

        @media (max-width: 480px) {
            body {
                padding: 10px 0;
            }

            .header h1 {
                font-size: 24px;
            }

            .controls {
                padding: 0 10px 10px;
            }

            .btn {
                padding: 10px 15px;
                font-size: 14px;
            }

            .stats {
                padding: 12px 20px;
                gap: 30px;
            }

            .container, #game {
                width: 380px;
            }
            
            #game {
                height: 380px;
                padding: 20px;
                border-radius: 12px;
            }
            
            .maze-piece {
                width: 75px;
                height: 75px;
            }
            
            .game_item {
                height: 65px;
                width: 65px;
                line-height: 65px;
                font-size: 18px;
                margin: 2px;
            }
        }

        .firework-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            bottom: 0;
            animation: launch 1s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
        }

        @keyframes launch {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-60vh);
            }
        }

        @keyframes explode {
            0% {
                transform: translate(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        .game_item {
            transition: opacity 0.3s ease;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            #game, #mirror-maze {
                margin-bottom: 20px;
            }
        }

        #mirror-maze {
            position: relative;
            overflow: hidden;
        }

        #mirror-maze canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            gap: 10px;
            flex-wrap: wrap;
            max-width: 500px;
        }

        .btn {
            min-width: 90px;
        }

        .maze-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .maze-controls .btn {
            padding: 6px 15px;
            font-size: 14px;
            min-width: 80px;
            height: 32px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            border-radius: 4px;
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .maze-controls .btn:hover {
            opacity: 1;
            transform: translateY(-1px);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>数字华容道</h1>
    </div>

    <div class="controls">
        <button class="btn btn-exit" onclick="exitGame()">退出</button>
    </div>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-label">时间</span>
            <span class="stat-value" id="timer">00:00.000</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">步数</span>
            <span class="stat-value" id="moves">0</span>
        </div>
    </div>

    <div class="container">
        <div id="game">
            <!-- 迷宫和数字方块将在这里动态生成 -->
        </div>
        <div id="mirror-maze">
            <!-- 镜像迷宫将在这里动态生成 -->
        </div>
    </div>

    <script>
        const MAZE = {
            N: 1,  // 0001 - 北墙
            E: 2,  // 0010 - 东墙
            S: 4,  // 0100 - 南墙
            W: 8   // 1000 - 西墙
        };

        const MAZE_CONFIG = {
            wallThickness: 12,      // 增加墙的厚度到12像素
            columns: 8,            
            rows: 8,
            backgroundColor: '#ffffff',
            mazeColor: '#000000',
            solveColor: '#cc3737',
            startColor: '#ff6b6b',  
            endColor: '#34ace0'     
        };

        // 生成迷宫
        function generateMaze() {
            const width = 8;
            const height = 8;
            const maze = Array(height).fill().map(() => Array(width).fill(15)); // 15 = 所有墙
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            
            function carve(x, y) {
                visited[y][x] = true;
                
                // 定义四个方向：北、东、南、西
                const directions = [
                    [0, -1, MAZE.N],
                    [1, 0, MAZE.E],
                    [0, 1, MAZE.S],
                    [-1, 0, MAZE.W]
                ];
                
                // 随机打乱方向
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // 尝试每个方向
                for (const [dx, dy, direction] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < width && newY >= 0 && newY < height && !visited[newY][newX]) {
                        // 移除当前单元格的墙
                        maze[y][x] &= ~direction;
                        
                        // 移除相邻单元格的对应墙
                        const opposite = {
                            [MAZE.N]: MAZE.S,
                            [MAZE.S]: MAZE.N,
                            [MAZE.E]: MAZE.W,
                            [MAZE.W]: MAZE.E
                        }[direction];
                        
                        maze[newY][newX] &= ~opposite;
                        
                        carve(newX, newY);
                    }
                }
            }
            
            // 从(0,0)开始生成迷宫
            carve(0, 0);
            
            // 确保入口和出口
            maze[0][0] &= ~MAZE.N;  // 移除入口的北墙
            maze[height-1][width-1] &= ~MAZE.S;  // 移除出口的南墙
            
            return maze;
        }

        // 初始化迷宫
        function initializeMazePieces() {
            const game = document.getElementById('game');
            game.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 520;     // 增加画布尺寸以适更粗的墙
            canvas.height = 520;
            const ctx = canvas.getContext('2d');
            
            // 生成���存迷宫
            currentMaze = generateMaze();  // 保存到全局变量
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 调整计算方式，确保迷宫完整显示
            const margin = 60; // 增加边距
            const availableSize = Math.min(canvas.width, canvas.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((canvas.width - mazeSize) / 2);
            const offsetY = Math.floor((canvas.height - mazeSize) / 2);
            
            // 移动到绘制起点
            ctx.translate(offsetX, offsetY);
            
            // 绘制迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 先绘制外边框
            ctx.fillRect(0, 0, mazeSize, MAZE_CONFIG.wallThickness); // 上边框
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mazeSize); // 左边框
            ctx.fillRect(mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mazeSize); // 右边框
            ctx.fillRect(0, mazeSize - MAZE_CONFIG.wallThickness, mazeSize, MAZE_CONFIG.wallThickness); // 下边框
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    // 绘制北墙
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制西墙
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制东墙（最后一列）
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制南墙（最后一行）
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness); // 入口
            ctx.clearRect(mazeSize - cellSize - MAZE_CONFIG.wallThickness, 
                         mazeSize - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness); // 出口
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeSize - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            game.appendChild(canvas);
            
            // 取画布的实际渲染尺寸
            const canvasRect = canvas.getBoundingClientRect();
            const gameRect = game.getBoundingClientRect();
            
            // 计画布相对于游戏容器的移
            const canvasOffsetX = canvasRect.left - gameRect.left;
            const canvasOffsetY = canvasRect.top - gameRect.top;
            
            // 重新计算华容道的大小和位置
            const puzzleSize = mazeSize - (MAZE_CONFIG.wallThickness * 2); // 减去左右两墙的厚度
            const blockSize = Math.floor(puzzleSize / 4); // 每个方块的大小
            const blockMargin = 0; // 移除方块间距
            
            // 计算华容道起始位考虑画布移边距
            const puzzleStartX = canvasOffsetX + offsetX - (MAZE_CONFIG.wallThickness / 2); // 更多地向移动
            const puzzleStartY = canvasOffsetY + offsetY - (MAZE_CONFIG.wallThickness / 2); // 更多地向上移动

            // 清除现有的方块
            const existingItems = game.querySelectorAll('.game_item');
            existingItems.forEach(item => item.remove());

            // 创建新的方块
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const gameItem = document.createElement("div");
                    gameItem.className = "game_item";
                    numberList[i][j] === 0 ? gameItem.innerText = "" : gameItem.innerText = numberList[i][j];
                    gameItem.setAttribute("row", i);
                    gameItem.setAttribute("col", j);
                    
                    // 计算每个块的具体位置
                    const left = puzzleStartX + (j * (blockSize + blockMargin));
                    const top = puzzleStartY + (i * (blockSize + blockMargin));
                    
                    // 设置方块样式
                    gameItem.style.left = left + 'px';
                    gameItem.style.top = top + 'px';
                    gameItem.style.width = blockSize + 'px';
                    gameItem.style.height = blockSize + 'px';
                    gameItem.style.lineHeight = blockSize + 'px';
                    gameItem.style.fontSize = Math.floor(blockSize * 0.4) + 'px';
                    
                    // 添加点击事件
                    gameItem.addEventListener('click', function() {
                        const row = parseInt(this.getAttribute('row'));
                        const col = parseInt(this.getAttribute('col'));
                        zeroRun(row, col);
                    });
                    
                    game.appendChild(gameItem);
                }
            }
            
            // 添加镜像迷宫的生成
            const mirrorMaze = document.getElementById('mirror-maze');
            mirrorMaze.innerHTML = '';
            
            const mirrorCanvas = document.createElement('canvas');
            mirrorCanvas.width = 520;
            mirrorCanvas.height = 520;
            const mirrorCtx = mirrorCanvas.getContext('2d');
            
            // 设置背景
            mirrorCtx.fillStyle = MAZE_CONFIG.backgroundColor;
            mirrorCtx.fillRect(0, 0, mirrorCanvas.width, mirrorCanvas.height);
            
            // 使用相同的计算方式，但使用不同的变量名
            const mirrorMargin = 60;
            const mirrorAvailableSize = Math.min(mirrorCanvas.width, mirrorCanvas.height) - (mirrorMargin * 2);
            const mirrorCellSize = Math.floor(mirrorAvailableSize / 8);
            const mirrorMazeSize = (mirrorCellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const mirrorOffsetX = Math.floor((mirrorCanvas.width - mirrorMazeSize) / 2);
            const mirrorOffsetY = Math.floor((mirrorCanvas.height - mirrorMazeSize) / 2);
            
            // 移动到绘制起点
            mirrorCtx.translate(mirrorOffsetX, mirrorOffsetY);
            
            // 在绘制镜像迷宫的外边框之前添加颜色设置
            mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 绘制镜像迷宫的外边框 - 不再清除入口和出口
            mirrorCtx.fillRect(0, 0, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 上边框 - 完整
            mirrorCtx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 左边框
            mirrorCtx.fillRect(mirrorMazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 右边框
            mirrorCtx.fillRect(0, mirrorMazeSize - MAZE_CONFIG.wallThickness, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 下边框 - 完整
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * mirrorCellSize;
                    const py = y * mirrorCellSize;
                    
                    // 对于镜像迷宫，始终绘制北墙和南墙
                    mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
                    mirrorCtx.fillRect(px, py, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px, py + mirrorCellSize, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    
                    // 对于镜像迷宫，始终绘制东墙和西墙
                    mirrorCtx.fillRect(px, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px + mirrorCellSize, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                }
            }
            
            mirrorMaze.appendChild(mirrorCanvas);
        }

        // 页面加载时初始化迷宫
        window.onload = function() {
            currentMaze = generateMaze(); // 确保页面加载时就生成迷宫
            initializeMazePieces();
        }

        // 新游戏按钮点击事件
        function startNewGame() {
            // 停止当前计时器
            stopTimer();
            isTimerStarted = false;
            document.getElementById('timer').textContent = '00:00.000';  // 更新初始显示格式
            
            // 重置游戏状态
            numberList = [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 0]
            ];
            zeroRow = 3;
            zeroCol = 3;
            moves = 0;
            document.getElementById('moves').textContent = '0';
            document.getElementById('timer').textContent = '00:00.000';
            
            // 重新生成迷宫和初始化方块
            currentMaze = generateMaze();
            initializeMazePieces();
            
            // 打乱方块
            chaos();
        }

        // 退出按钮点击事件
        function exitGame() {
            if (confirm('确定要退出游戏吗？')) {
                window.location.href = '/';
            }
        }

        // 修改寻路相关代码
        function findPath(maze) {
            const width = 8;
            const height = 8;
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const path = [];
            
            function canMove(fromX, fromY, toX, toY) {
                // 检查是否可以从一个格子移动到另一个格子
                if (toX < 0 || toX >= width || toY < 0 || toY >= height) {
                    return false;
                }
                
                // 检查两个格子之间是否有墙
                if (toX > fromX) { // 向东移动
                    return !(maze[fromY][fromX] & MAZE.E);
                } else if (toX < fromX) { // 向西移动
                    return !(maze[fromY][fromX] & MAZE.W);
                } else if (toY > fromY) { // 向南移动
                    return !(maze[fromY][fromX] & MAZE.S);
                } else if (toY < fromY) { // 向北移动
                    return !(maze[fromY][fromX] & MAZE.N);
                }
                return false;
            }
            
            function dfs(x, y) {
                if (x === width-1 && y === height-1) {
                    path.push([x, y]);
                    return true;
                }
                
                visited[y][x] = true;
                path.push([x, y]);
                
                // 定义四个方向的移动
                const moves = [
                    [0, -1], // 北
                    [1, 0],  // 东
                    [0, 1],  // 南
                    [-1, 0]  // 西
                ];
                
                // 随机打乱移动顺序，使路径更随机
                for (let i = moves.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [moves[i], moves[j]] = [moves[j], moves[i]];
                }
                
                for (const [dx, dy] of moves) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (!visited[newY]?.[newX] && canMove(x, y, newX, newY)) {
                        if (dfs(newX, newY)) {
                            return true;
                        }
                    }
                }
                
                path.pop();
                return false;
            }
            
            if (dfs(0, 0)) {
                return path;
            }
            return null;
        }

        // 修改显示解法函数
        function solveMaze() {
            // 停止计时器
            stopTimer();
            isTimerStarted = false;

            if (!currentMaze) {
                console.error('No maze available');
                return;
            }
            
            // 完全隐藏华容道方块
            const gameItems = document.querySelectorAll('.game_item');
            gameItems.forEach(item => {
                item.style.display = 'none';
            });
            
            const game = document.getElementById('game');
            const canvas = game.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            
            // 获取当前画布的变换状态
            const currentTransform = ctx.getTransform();
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 使用当前的变换状态
            ctx.setTransform(currentTransform);
            
            // 绘迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 使用与初始化时相同的尺寸
            const margin = 60;
            const availableSize = Math.min(canvas.width, canvas.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 绘制外边框
            ctx.fillRect(0, 0, mazeSize, MAZE_CONFIG.wallThickness);
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(0, mazeSize - MAZE_CONFIG.wallThickness, mazeSize, MAZE_CONFIG.wallThickness);
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness);
            ctx.clearRect(mazeSize - cellSize - MAZE_CONFIG.wallThickness, 
                         mazeSize - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness);
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeSize - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            // 获取并绘制解决路径
            const path = findPath(currentMaze);
            
            if (path && path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = MAZE_CONFIG.solveColor;
                ctx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const [firstX, firstY] = path[0];
                ctx.moveTo(firstX * cellSize + cellSize/2, firstY * cellSize + cellSize/2);
                
                for (const [x, y] of path) {
                    ctx.lineTo(x * cellSize + cellSize/2, y * cellSize + cellSize/2);
                }
                
                ctx.stroke();
            }
            
            // 添加返回按钮
            const backButton = document.createElement('button');
            backButton.className = 'btn btn-new';
            backButton.style.position = 'absolute';
            backButton.style.top = '20px';
            backButton.style.right = '20px';
            backButton.innerText = '返回游戏';
            backButton.onclick = function() {
                backButton.remove();
                gameItems.forEach(item => {
                    item.style.display = 'flex';
                });
            };
            game.appendChild(backButton);
            
            // 在镜像迷宫上也显示解决路径
            const mirrorCanvas = document.querySelector('#mirror-maze canvas');
            if (mirrorCanvas) {
                const mirrorCtx = mirrorCanvas.getContext('2d');
                if (path && path.length > 0) {
                    mirrorCtx.beginPath();
                    mirrorCtx.strokeStyle = MAZE_CONFIG.solveColor;
                    mirrorCtx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                    mirrorCtx.lineCap = 'round';
                    mirrorCtx.lineJoin = 'round';
                    
                    const [firstX, firstY] = path[0];
                    mirrorCtx.moveTo(firstX * mirrorCellSize + mirrorCellSize/2, firstY * mirrorCellSize + mirrorCellSize/2);
                    
                    for (const [x, y] of path) {
                        mirrorCtx.lineTo(x * mirrorCellSize + mirrorCellSize/2, y * mirrorCellSize + mirrorCellSize/2);
                    }
                    
                    mirrorCtx.stroke();
                }
            }
        }

        // 在全局作用域添加变量
        let currentMaze = null;

        // 初始布局
        let numberList = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 0]
        ];
        let zeroRow = 3;
        let zeroCol = 3;
        let moves = 0;
        let timer;
        let startTime = 0;  // 添加开始时间变量
        let isShuffling = false;
        let isTimerStarted = false;  // 添加标记，记录计时器是否已启动

        // 添加华容道的移动逻辑
        function zeroRun(row, col) {
            if (row !== zeroRow && col !== zeroCol) {
                return;
            }
            
            if (numberList[row][col] === 0) {
                return;
            }

            // 第一次移动时启动计时器
            if (!isTimerStarted) {
                startTimer();
                isTimerStarted = true;
            }

            const oldZeroRow = zeroRow;
            const oldZeroCol = zeroCol;

            if (row === zeroRow) {
                const direction = col > zeroCol ? 1 : -1;
                for (let i = zeroCol; i !== col; i += direction) {
                    numberList[row][i] = numberList[row][i + direction];
                }
                numberList[row][col] = 0;
                zeroCol = col;
            } else {
                const direction = row > zeroRow ? 1 : -1;
                for (let i = zeroRow; i !== row; i += direction) {
                    numberList[i][col] = numberList[i + direction][col];
                }
                numberList[row][col] = 0;
                zeroRow = row;
            }

            if (oldZeroRow !== zeroRow || oldZeroCol !== zeroCol) {
                moves++;
                document.getElementById('moves').textContent = moves;
            }

            renderGame();
        }

        // 渲染华容道
        function renderGame() {
            const game = document.getElementById("game");
            const items = game.querySelectorAll('.game_item');
            
            items.forEach(item => {
                const row = parseInt(item.getAttribute('row'));
                const col = parseInt(item.getAttribute('col'));
                item.innerText = numberList[row][col] === 0 ? "" : numberList[row][col];
            });
        }

        // 打乱华容道
        function chaos() {
            isShuffling = true;
            const rCount = Math.floor(Math.random() * 50 + 50);
            for(let i = 0; i <= rCount; i++) {
                const rRow = Math.floor(Math.random() * 4);
                const rCol = Math.floor(Math.random() * 4);
                // 临时禁用计时器启动
                const tempIsTimerStarted = isTimerStarted;
                isTimerStarted = true;  // 防止在打乱过程中启动计时器
                zeroRun(rRow, rCol);
                isTimerStarted = tempIsTimerStarted;
            }
            isShuffling = false;
        }

        // 添加事件监听
        document.getElementById("game").addEventListener("click", function(e) {
            let clickedItem = e.target;
            if (!clickedItem.hasAttribute("row")) {
                clickedItem = clickedItem.closest(".game_item");
            }
            
            if (clickedItem && clickedItem.className === "game_item") {
                const row = parseInt(clickedItem.getAttribute("row"));
                const col = parseInt(clickedItem.getAttribute("col"));
                
                if (row === zeroRow || col === zeroCol) {
                    zeroRun(row, col);
                }
            }
        });

        // 添加键盘控制
        document.onkeydown = function(e) {
            switch(e.code) {
                case "ArrowUp":
                    if (zeroRow === 3) return;
                    zeroRun(zeroRow + 1, zeroCol);
                    break;
                case "ArrowDown":
                    if (zeroRow === 0) return;
                    zeroRun(zeroRow - 1, zeroCol);
                    break;
                case "ArrowLeft":
                    if (zeroCol === 3) return;
                    zeroRun(zeroRow, zeroCol + 1);
                    break;
                case "ArrowRight":
                    if (zeroCol === 0) return;
                    zeroRun(zeroRow, zeroCol - 1);
                    break;
            }
        }

        // 添加窗口大小变化时重新计算位置的处理
        window.addEventListener('resize', function() {
            // 添加防抖处理
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                initializeMazePieces();
            }, 250);
        });

        // 修改 CSS 样式，添加过渡效果
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .game_item {
                transition: opacity 0.3s ease;
            }
        `;
        document.head.appendChild(styleElement);

        // 添加新的变量
        let startX = 0;
        let startY = 0;
        let previewCtx = null;
        let previewCanvas = null;

        // 在 initializeDrawing 函数之前添加以下变量声明
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingCtx = null;
        let drawingCanvas = null;

        // 修改 getCoordinates 函数
        function getCoordinates(e) {
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            // 使用与迷宫生成时完全相同的计算方式
            const margin = 60;
            const availableSize = Math.min(rect.width, rect.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((rect.width - mazeSize) / 2);
            const offsetY = Math.floor((rect.height - mazeSize) / 2);
            
            let clientX, clientY;
            if (e.type.includes('touch')) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // 计算相对于迷宫原点的坐标
            return [
                clientX - rect.left - offsetX,
                clientY - rect.top - offsetY
            ];
        }

        // 修改 getNearestCellCenter 函数
        function getNearestCellCenter(x, y) {
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            // 使用与迷宫生成时完全相同的计算方式
            const margin = 60;
            const availableSize = Math.min(rect.width, rect.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((rect.width - mazeSize) / 2);
            const offsetY = Math.floor((rect.height - mazeSize) / 2);
            
            // 计算格子索引（考虑第一个格���的度）
            const col = Math.floor((x - MAZE_CONFIG.wallThickness) / cellSize);
            const row = Math.floor((y - MAZE_CONFIG.wallThickness) / cellSize);
            
            // 确保索引在有效范围内
            const validCol = Math.max(0, Math.min(7, col));
            const validRow = Math.max(0, Math.min(7, row));
            
            // 计算格子中心点坐标
            const centerX = validCol * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
            const centerY = validRow * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
            
            return {
                x: centerX + offsetX,
                y: centerY + offsetY,
                row: validRow,
                col: validCol
            };
        }

        // 修改 startDrawing 函数
        function startDrawing(e) {
            // 阻止默认行为
            e.preventDefault();
            
            const coords = getCoordinates(e);
            const [x, y] = coords;
            
            // 获取最近的格子中心点
            const center = getNearestCellCenter(x, y);
            
            isDrawing = true;
            startX = center.x;
            startY = center.y;
            lastX = center.x;
            lastY = center.y;
        }

        // 添加一个全局变量来存储所有绘制的线段
        let drawnLines = [];

        // 修改 finishDrawing 函数，添加线段记录
        function finishDrawing(e) {
            if (!isDrawing) return;
            
            const [x, y] = getCoordinates(e);
            const center = getNearestCellCenter(x, y);
            const currentX = center.x;
            const currentY = center.y;
            
            const dx = Math.abs(currentX - startX);
            const dy = Math.abs(currentY - startY);
            
            // 记录新绘制的线段
            const line = {
                x1: startX,
                y1: startY,
                x2: dx > dy ? currentX : startX,
                y2: dx > dy ? startY : currentY,
                isHorizontal: dx > dy
            };
            drawnLines.push(line);
            
            // 绘制线段
            drawingCtx.save();
            drawingCtx.beginPath();
            drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            drawingCtx.shadowBlur = 4;
            drawingCtx.shadowOffsetX = 2;
            drawingCtx.shadowOffsetY = 2;
            drawingCtx.lineWidth = MAZE_CONFIG.wallThickness;
            drawingCtx.lineCap = 'round';
            drawingCtx.lineJoin = 'round';
            drawingCtx.strokeStyle = '#4a90e2';
            
            drawingCtx.moveTo(line.x1, line.y1);
            drawingCtx.lineTo(line.x2, line.y2);
            drawingCtx.stroke();
            drawingCtx.restore();
            
            // 移除端点标记的绘制
            // drawEndpoint(drawingCtx, startX, startY, '#ff6b6b');
            // drawEndpoint(drawingCtx, currentX, currentY, '#4a90e2');
            
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            isDrawing = false;
        }

        // 修改 handleDoubleClick 函数
        function handleDoubleClick(e) {
            const [x, y] = getCoordinates(e);
            const center = getNearestCellCenter(x, y);
            const clickX = center.x;
            const clickY = center.y;
            
            // 查找被点击的线段
            const clickedLineIndex = drawnLines.findIndex(line => {
                if (line.isHorizontal) {
                    // 水平线段：检查 Y 坐标是否匹配，以及 X 坐标是否在范围内
                    const minX = Math.min(line.x1, line.x2);
                    const maxX = Math.max(line.x1, line.x2);
                    return Math.abs(clickY - line.y1) <= MAZE_CONFIG.wallThickness &&
                           clickX >= minX - MAZE_CONFIG.wallThickness &&
                           clickX <= maxX + MAZE_CONFIG.wallThickness;
                } else {
                    // 垂直线段：检查 X 坐标是否匹配，以及 Y 坐标是否在范围内
                    const minY = Math.min(line.y1, line.y2);
                    const maxY = Math.max(line.y1, line.y2);
                    return Math.abs(clickX - line.x1) <= MAZE_CONFIG.wallThickness &&
                           clickY >= minY - MAZE_CONFIG.wallThickness &&
                           clickY <= maxY + MAZE_CONFIG.wallThickness;
                }
            });
            
            if (clickedLineIndex !== -1) {
                // 删除找到的线段
                drawnLines.splice(clickedLineIndex, 1);
                
                // 清除画布
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                
                // 重新绘制所有保留的线段
                drawnLines.forEach(line => {
                    drawingCtx.beginPath();
                    drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    drawingCtx.shadowBlur = 4;
                    drawingCtx.shadowOffsetX = 2;
                    drawingCtx.shadowOffsetY = 2;
                    drawingCtx.lineWidth = MAZE_CONFIG.wallThickness;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';
                    drawingCtx.strokeStyle = '#4a90e2';
                    
                    drawingCtx.moveTo(line.x1, line.y1);
                    drawingCtx.lineTo(line.x2, line.y2);
                    drawingCtx.stroke();
                });
                
                // 最后重新绘制所有中心点
                drawCellCenters();
            }
        }

        // 修改 clearDrawing 函数
        function clearDrawing() {
            if (drawingCtx) {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawCellCenters();
                // 清空线段数组
                drawnLines = [];
            }
            
            if (previewCtx) {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            }
        }

        // 修改 drawCellCenters 函数
        function drawCellCenters() {
            if (!drawingCtx) return;
            
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            const margin = 60;
            const availableSize = Math.min(520, 520) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            const offsetX = Math.floor((520 - mazeSize) / 2);
            const offsetY = Math.floor((520 - mazeSize) / 2);
            
            // 遍历所有格子
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const centerX = x * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
                    const centerY = y * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
                    
                    // 使用统一的样式绘制中心点
                    drawingCtx.beginPath();
                    drawingCtx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                    drawingCtx.arc(centerX + offsetX, centerY + offsetY, 2, 0, Math.PI * 2);
                    drawingCtx.fill();
                }
            }
        }

        // 修改计时器启动函数
        function startTimer() {
            startTime = Date.now();  // 记录开始时间
            document.getElementById('timer').textContent = '00:00.000';
            timer = setInterval(function() {
                const currentTime = Date.now();
                const elapsedTime = currentTime - startTime;
                
                // 计算分钟、秒和毫秒
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const milliseconds = elapsedTime % 1000;
                
                // 格式化显示
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }, 10);  // 每10毫秒更新一次显示
        }

        // 修改计时器停止函数
        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
                
                // 记录最终时间
                const finalTime = Date.now() - startTime;
                const minutes = Math.floor(finalTime / 60000);
                const seconds = Math.floor((finalTime % 60000) / 1000);
                const milliseconds = finalTime % 1000;
                
                // 更新显示最终时间
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }
        }

        // 修改 initializeMazePieces 函数，在末尾添加：
        const originalInitializeMazePieces = initializeMazePieces;
        initializeMazePieces = function() {
            originalInitializeMazePieces();
            clearDrawing();
            initializeDrawing();
        }

        // 修改控制按钮区域，添加清除绘图按钮
        const controlsDiv = document.querySelector('.controls');
        const clearButton = document.createElement('button');
        clearButton.className = 'btn btn-new';
        clearButton.innerText = '清除绘图';
        clearButton.onclick = clearDrawing;
        controlsDiv.appendChild(clearButton);

        // 页面加载完成后初始化绘图功能
        window.addEventListener('load', initializeDrawing);

        // 添加初始化绘图功能函数
        function initializeDrawing() {
            const mirrorMaze = document.getElementById('mirror-maze');
            
            // 创建绘图层
            drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = 520;
            drawingCanvas.height = 520;
            drawingCanvas.style.position = 'absolute';
            drawingCanvas.style.top = '0';
            drawingCanvas.style.left = '0';
            drawingCanvas.style.pointerEvents = 'all';
            drawingCanvas.style.cursor = 'crosshair';
            drawingCtx = drawingCanvas.getContext('2d');
            
            // 创建预览层
            previewCanvas = document.createElement('canvas');
            previewCanvas.width = 520;
            previewCanvas.height = 520;
            previewCanvas.style.position = 'absolute';
            previewCanvas.style.top = '0';
            previewCanvas.style.left = '0';
            previewCanvas.style.pointerEvents = 'none';
            previewCtx = previewCanvas.getContext('2d');
            
            // 创建控制按钮容器
            const mazeControls = document.createElement('div');
            mazeControls.className = 'maze-controls';
            
            // 创建新游戏按钮
            const newGameButton = document.createElement('button');
            newGameButton.className = 'btn btn-new';
            newGameButton.innerText = '新游戏';
            newGameButton.onclick = startNewGame;
            
            // 创建提交答案按钮
            const solveButton = document.createElement('button');
            solveButton.className = 'btn btn-solve';
            solveButton.innerText = '提交答案';
            solveButton.onclick = solveMaze;
            
            // 创建清除绘图按钮
            const clearButton = document.createElement('button');
            clearButton.className = 'btn btn-new';
            clearButton.innerText = '清除绘图';
            clearButton.onclick = clearDrawing;
            
            // 添加按钮到控制容器
            mazeControls.appendChild(newGameButton);
            mazeControls.appendChild(solveButton);
            mazeControls.appendChild(clearButton);
            
            // 添加所有元素到镜像迷宫
            mirrorMaze.appendChild(drawingCanvas);
            mirrorMaze.appendChild(previewCanvas);
            mirrorMaze.appendChild(mazeControls);
            
            // 立即绘制中心点
            drawCellCenters();
            
            // 添加事件监听器
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', showPreview);
            drawingCanvas.addEventListener('mouseup', finishDrawing);
            drawingCanvas.addEventListener('mouseout', cancelDrawing);
            
            // 触摸设备支持
            drawingCanvas.addEventListener('touchstart', handleTouchStart);
            drawingCanvas.addEventListener('touchmove', handleTouchMove);
            drawingCanvas.addEventListener('touchend', finishDrawing);
            
            // 添加双击事件监听器
            drawingCanvas.addEventListener('dblclick', handleDoubleClick);
        }

        // 添加取消绘制函数
        function cancelDrawing() {
            if (!isDrawing) return;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            isDrawing = false;
        }

        // 添加触摸事件处理函数
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            showPreview(mouseEvent);
        }

        // 修改 showPreview 函数
        function showPreview(e) {
            if (!isDrawing) return;
            
            const [x, y] = getCoordinates(e);
            const center = getNearestCellCenter(x, y);
            const currentX = center.x;
            const currentY = center.y;
            
            // 清除之前的预览
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            previewCtx.beginPath();
            previewCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            previewCtx.shadowBlur = 4;
            previewCtx.shadowOffsetX = 2;
            previewCtx.shadowOffsetY = 2;
            previewCtx.lineWidth = MAZE_CONFIG.wallThickness;
            previewCtx.lineCap = 'round';
            previewCtx.lineJoin = 'round';
            // 使用单一颜色替代渐变
            previewCtx.strokeStyle = '#4a90e2';
            previewCtx.globalAlpha = 0.7;
            
            previewCtx.moveTo(startX, startY);
            const dx = Math.abs(currentX - startX);
            const dy = Math.abs(currentY - startY);
            if (dx > dy) {
                previewCtx.lineTo(currentX, startY);
            } else {
                previewCtx.lineTo(startX, currentY);
            }
            previewCtx.stroke();
        }
    </script>
</body>
</html> 