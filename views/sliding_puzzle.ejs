<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title><%= title %></title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #e8f4f8, #d1e9f5);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .header {
            width: 100%;
            background: linear-gradient(135deg, #4a90e2, #67a6e5);
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            width: 100%;
            max-width: 408px;
            padding: 0 15px 15px;
            box-sizing: border-box;
            gap: 15px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            color: white;
            flex: 1;
            max-width: 120px;
            font-weight: 500;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-new {
            background: linear-gradient(135deg, #34ace0, #63cdff);
        }

        .btn-exit {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .btn-solve {
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
        }

        .stats {
            background-color: white;
            padding: 15px 30px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.1);
            margin: 0 0 20px;
            display: flex;
            gap: 40px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8fa6;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
        }

        .container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
            gap: 20px;
        }

        #game, #mirror-maze {
            width: 100%;
            max-width: 520px;
            height: 520px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(74, 144, 226, 0.15);
            padding: 25px;
            box-sizing: border-box;
            position: relative;
            overflow: visible;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .maze-piece {
            position: absolute;
            width: 90px;
            height: 90px;
            background: white;
            z-index: 0;
            margin: 2px;
        }

        #drawing-board {
            width: 408px;
            height: 408px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            cursor: crosshair;
        }

        .game_item {
            position: absolute;
            z-index: 2;
            border-radius: 0;
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
            color: white;
            text-align: center;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            transition: transform 0.2s ease;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game_item:empty {
            background: transparent;
            box-shadow: none;
            pointer-events: none;
            opacity: 0;
        }

        .game_item {
            z-index: 3;
        }

        @media (max-width: 480px) {
            body {
                padding: 10px 0;
            }

            .header h1 {
                font-size: 24px;
            }

            .controls {
                padding: 0 10px 10px;
            }

            .btn {
                padding: 10px 15px;
                font-size: 14px;
            }

            .stats {
                padding: 12px 20px;
                gap: 30px;
            }

            .container, #game {
                width: 380px;
            }
            
            #game {
                height: 380px;
                padding: 20px;
                border-radius: 12px;
            }
            
            .maze-piece {
                width: 75px;
                height: 75px;
            }
            
            .game_item {
                height: 65px;
                width: 65px;
                line-height: 65px;
                font-size: 18px;
                margin: 2px;
            }
        }

        .firework-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            bottom: 0;
            animation: launch 1s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
        }

        @keyframes launch {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-60vh);
            }
        }

        @keyframes explode {
            0% {
                transform: translate(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        .game_item {
            transition: opacity 0.3s ease;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            #game, #mirror-maze {
                margin-bottom: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>数字华容道</h1>
    </div>

    <div class="controls">
        <button class="btn btn-exit" onclick="exitGame()">退出</button>
        <button class="btn btn-new" onclick="startNewGame()">新游戏</button>
        <button class="btn btn-solve" onclick="solveMaze()">显示解法</button>
    </div>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-label">时间</span>
            <span class="stat-value" id="timer">00:00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">步数</span>
            <span class="stat-value" id="moves">0</span>
        </div>
    </div>

    <div class="container">
        <div id="game">
            <!-- 迷宫和数字方块将在这里动态生成 -->
        </div>
        <div id="mirror-maze">
            <!-- 镜像迷宫将在这里动态生成 -->
        </div>
    </div>

    <script>
        const MAZE = {
            N: 1,  // 0001 - 北墙
            E: 2,  // 0010 - 东墙
            S: 4,  // 0100 - 南墙
            W: 8   // 1000 - 西墙
        };

        const MAZE_CONFIG = {
            wallThickness: 12,      // 增加墙的厚度到12像素
            columns: 8,            
            rows: 8,
            backgroundColor: '#ffffff',
            mazeColor: '#000000',
            solveColor: '#cc3737',
            startColor: '#ff6b6b',  
            endColor: '#34ace0'     
        };

        // 生成迷宫
        function generateMaze() {
            const width = 8;
            const height = 8;
            const maze = Array(height).fill().map(() => Array(width).fill(15)); // 15 = 所有墙
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            
            function carve(x, y) {
                visited[y][x] = true;
                
                // 定义四个方向：北、东、南、西
                const directions = [
                    [0, -1, MAZE.N],
                    [1, 0, MAZE.E],
                    [0, 1, MAZE.S],
                    [-1, 0, MAZE.W]
                ];
                
                // 随机打乱方向
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // 尝试每个方向
                for (const [dx, dy, direction] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < width && newY >= 0 && newY < height && !visited[newY][newX]) {
                        // 移除当前单元格的墙
                        maze[y][x] &= ~direction;
                        
                        // 移除相邻单元格的对应墙
                        const opposite = {
                            [MAZE.N]: MAZE.S,
                            [MAZE.S]: MAZE.N,
                            [MAZE.E]: MAZE.W,
                            [MAZE.W]: MAZE.E
                        }[direction];
                        
                        maze[newY][newX] &= ~opposite;
                        
                        carve(newX, newY);
                    }
                }
            }
            
            // 从(0,0)开始生成迷宫
            carve(0, 0);
            
            // 确保入口和出口
            maze[0][0] &= ~MAZE.N;  // 移除入口的北墙
            maze[height-1][width-1] &= ~MAZE.S;  // 移除出口的南墙
            
            return maze;
        }

        // 初始化迷宫
        function initializeMazePieces() {
            const game = document.getElementById('game');
            game.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = 520;     // 增加画布尺寸以适应更粗的墙
            canvas.height = 520;
            const ctx = canvas.getContext('2d');
            
            // 生成并保存迷宫
            currentMaze = generateMaze();  // 保存到全局变量
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 调整计算方式，确保迷宫完整显示
            const margin = 60; // 增加边距
            const availableSize = Math.min(canvas.width, canvas.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((canvas.width - mazeSize) / 2);
            const offsetY = Math.floor((canvas.height - mazeSize) / 2);
            
            // 移动到绘制起点
            ctx.translate(offsetX, offsetY);
            
            // 绘制迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 先绘制外边框
            ctx.fillRect(0, 0, mazeSize, MAZE_CONFIG.wallThickness); // 上边框
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mazeSize); // 左边框
            ctx.fillRect(mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mazeSize); // 右边框
            ctx.fillRect(0, mazeSize - MAZE_CONFIG.wallThickness, mazeSize, MAZE_CONFIG.wallThickness); // 下边框
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    // 绘制北墙
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制西墙
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制东墙（最后一列）
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制南墙（最后一行）
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness); // 入口
            ctx.clearRect(mazeSize - cellSize - MAZE_CONFIG.wallThickness, 
                         mazeSize - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness); // 出口
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeSize - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            game.appendChild(canvas);
            
            // 取画布的实际渲染尺寸
            const canvasRect = canvas.getBoundingClientRect();
            const gameRect = game.getBoundingClientRect();
            
            // 计画布相对于游戏容器的偏移
            const canvasOffsetX = canvasRect.left - gameRect.left;
            const canvasOffsetY = canvasRect.top - gameRect.top;
            
            // 重新计算华容道的大小和位置
            const puzzleSize = mazeSize - (MAZE_CONFIG.wallThickness * 2); // 减去左右两墙的厚度
            const blockSize = Math.floor(puzzleSize / 4); // 每个方块的大小
            const blockMargin = 0; // 移除方块间距
            
            // 计算华容道的起始位置，考虑画布偏移和边距
            const puzzleStartX = canvasOffsetX + offsetX - (MAZE_CONFIG.wallThickness / 2); // 更多地向移动
            const puzzleStartY = canvasOffsetY + offsetY - (MAZE_CONFIG.wallThickness / 2); // 更多地向上移动

            // 清除现有的方块
            const existingItems = game.querySelectorAll('.game_item');
            existingItems.forEach(item => item.remove());

            // 创建新的方块
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const gameItem = document.createElement("div");
                    gameItem.className = "game_item";
                    numberList[i][j] === 0 ? gameItem.innerText = "" : gameItem.innerText = numberList[i][j];
                    gameItem.setAttribute("row", i);
                    gameItem.setAttribute("col", j);
                    
                    // 计算每个方块的具体位置
                    const left = puzzleStartX + (j * (blockSize + blockMargin));
                    const top = puzzleStartY + (i * (blockSize + blockMargin));
                    
                    // 设置方块样式
                    gameItem.style.left = left + 'px';
                    gameItem.style.top = top + 'px';
                    gameItem.style.width = blockSize + 'px'; // 移除 margin 的减法
                    gameItem.style.height = blockSize + 'px';
                    gameItem.style.lineHeight = blockSize + 'px';
                    gameItem.style.fontSize = Math.floor(blockSize * 0.4) + 'px'; // 动态调整字体大小
                    
                    game.appendChild(gameItem);
                }
            }
            
            // 添加镜像迷宫的生成
            const mirrorMaze = document.getElementById('mirror-maze');
            mirrorMaze.innerHTML = '';
            
            const mirrorCanvas = document.createElement('canvas');
            mirrorCanvas.width = 520;
            mirrorCanvas.height = 520;
            const mirrorCtx = mirrorCanvas.getContext('2d');
            
            // 设置背景
            mirrorCtx.fillStyle = MAZE_CONFIG.backgroundColor;
            mirrorCtx.fillRect(0, 0, mirrorCanvas.width, mirrorCanvas.height);
            
            // 使用相同的计算方式，但使用不同的变量名
            const mirrorMargin = 60;
            const mirrorAvailableSize = Math.min(mirrorCanvas.width, mirrorCanvas.height) - (mirrorMargin * 2);
            const mirrorCellSize = Math.floor(mirrorAvailableSize / 8);
            const mirrorMazeSize = (mirrorCellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const mirrorOffsetX = Math.floor((mirrorCanvas.width - mirrorMazeSize) / 2);
            const mirrorOffsetY = Math.floor((mirrorCanvas.height - mirrorMazeSize) / 2);
            
            // 移动到绘制起点
            mirrorCtx.translate(mirrorOffsetX, mirrorOffsetY);
            
            // 在绘制镜像迷宫的外边框之前添加颜色设置
            mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 绘制镜像迷宫的外边框 - 不再清除入口和出口
            mirrorCtx.fillRect(0, 0, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 上边框 - 完整
            mirrorCtx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 左边框
            mirrorCtx.fillRect(mirrorMazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 右边框
            mirrorCtx.fillRect(0, mirrorMazeSize - MAZE_CONFIG.wallThickness, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 下边框 - 完整
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * mirrorCellSize;
                    const py = y * mirrorCellSize;
                    
                    // 对于镜像迷宫，始终绘制北墙和南墙
                    mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
                    mirrorCtx.fillRect(px, py, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px, py + mirrorCellSize, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    
                    // 对于镜像迷宫，始终绘制东墙和西墙
                    mirrorCtx.fillRect(px, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px + mirrorCellSize, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                }
            }
            
            mirrorMaze.appendChild(mirrorCanvas);
        }

        // 页面加载时初始化迷宫
        window.onload = function() {
            currentMaze = generateMaze(); // 确保页面加载时就生成迷宫
            initializeMazePieces();
        }

        // 新游戏按钮点击事件
        function startNewGame() {
            currentMaze = generateMaze(); // 始新游戏时生成新迷宫
            initializeMazePieces();
        }

        // 退出按钮点击事件
        function exitGame() {
            if (confirm('确定要退出游戏吗？')) {
                window.location.href = '/';
            }
        }

        // 修改寻路相关代码
        function findPath(maze) {
            const width = 8;
            const height = 8;
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const path = [];
            
            function canMove(fromX, fromY, toX, toY) {
                // 检查是否可以从一个格子移动到另一个格子
                if (toX < 0 || toX >= width || toY < 0 || toY >= height) {
                    return false;
                }
                
                // 检查两个格子之间是否有墙
                if (toX > fromX) { // 向东移动
                    return !(maze[fromY][fromX] & MAZE.E);
                } else if (toX < fromX) { // 向西移动
                    return !(maze[fromY][fromX] & MAZE.W);
                } else if (toY > fromY) { // 向南移动
                    return !(maze[fromY][fromX] & MAZE.S);
                } else if (toY < fromY) { // 向北移动
                    return !(maze[fromY][fromX] & MAZE.N);
                }
                return false;
            }
            
            function dfs(x, y) {
                if (x === width-1 && y === height-1) {
                    path.push([x, y]);
                    return true;
                }
                
                visited[y][x] = true;
                path.push([x, y]);
                
                // 定义四个方向的移动
                const moves = [
                    [0, -1], // 北
                    [1, 0],  // 东
                    [0, 1],  // 南
                    [-1, 0]  // 西
                ];
                
                // 随机打乱移动顺序，使路径更随机
                for (let i = moves.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [moves[i], moves[j]] = [moves[j], moves[i]];
                }
                
                for (const [dx, dy] of moves) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (!visited[newY]?.[newX] && canMove(x, y, newX, newY)) {
                        if (dfs(newX, newY)) {
                            return true;
                        }
                    }
                }
                
                path.pop();
                return false;
            }
            
            if (dfs(0, 0)) {
                return path;
            }
            return null;
        }

        // 修改显示解法函数
        function solveMaze() {
            if (!currentMaze) {
                console.error('No maze available');
                return;
            }
            
            // 完全隐藏华容道方块
            const gameItems = document.querySelectorAll('.game_item');
            gameItems.forEach(item => {
                item.style.display = 'none';
            });
            
            const game = document.getElementById('game');
            const canvas = game.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            
            // 获取当前画布的变换状态
            const currentTransform = ctx.getTransform();
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 使用当前的变换状态
            ctx.setTransform(currentTransform);
            
            // 绘制迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 使用与初始化时相同的尺寸
            const margin = 60;
            const availableSize = Math.min(canvas.width, canvas.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 绘制外边框
            ctx.fillRect(0, 0, mazeSize, MAZE_CONFIG.wallThickness);
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(0, mazeSize - MAZE_CONFIG.wallThickness, mazeSize, MAZE_CONFIG.wallThickness);
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness);
            ctx.clearRect(mazeSize - cellSize - MAZE_CONFIG.wallThickness, 
                         mazeSize - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness);
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeSize - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            // 获取并绘制解决路径
            const path = findPath(currentMaze);
            
            if (path && path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = MAZE_CONFIG.solveColor;
                ctx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const [firstX, firstY] = path[0];
                ctx.moveTo(firstX * cellSize + cellSize/2, firstY * cellSize + cellSize/2);
                
                for (const [x, y] of path) {
                    ctx.lineTo(x * cellSize + cellSize/2, y * cellSize + cellSize/2);
                }
                
                ctx.stroke();
            }
            
            // 添加返回按钮
            const backButton = document.createElement('button');
            backButton.className = 'btn btn-new';
            backButton.style.position = 'absolute';
            backButton.style.top = '20px';
            backButton.style.right = '20px';
            backButton.innerText = '返回游戏';
            backButton.onclick = function() {
                backButton.remove();
                gameItems.forEach(item => {
                    item.style.display = 'flex';
                });
            };
            game.appendChild(backButton);
            
            // 在镜像迷宫上也显示解决路径
            const mirrorCanvas = document.querySelector('#mirror-maze canvas');
            if (mirrorCanvas) {
                const mirrorCtx = mirrorCanvas.getContext('2d');
                if (path && path.length > 0) {
                    mirrorCtx.beginPath();
                    mirrorCtx.strokeStyle = MAZE_CONFIG.solveColor;
                    mirrorCtx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                    mirrorCtx.lineCap = 'round';
                    mirrorCtx.lineJoin = 'round';
                    
                    const [firstX, firstY] = path[0];
                    mirrorCtx.moveTo(firstX * mirrorCellSize + mirrorCellSize/2, firstY * mirrorCellSize + mirrorCellSize/2);
                    
                    for (const [x, y] of path) {
                        mirrorCtx.lineTo(x * mirrorCellSize + mirrorCellSize/2, y * mirrorCellSize + mirrorCellSize/2);
                    }
                    
                    mirrorCtx.stroke();
                }
            }
        }

        // 在全局作用域添加变量
        let currentMaze = null;

        // 初始布局
        let numberList = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 0]
        ];
        let zeroRow = 3;
        let zeroCol = 3;
        let moves = 0;
        let timer;
        let seconds = 0;
        let isShuffling = false;

        // 添加华容道的移动逻辑
        function zeroRun(row, col) {
            if (row !== zeroRow && col !== zeroCol) {
                return;
            }
            
            if (numberList[row][col] === 0) {
                return;
            }

            const oldZeroRow = zeroRow;
            const oldZeroCol = zeroCol;

            if (row === zeroRow) {
                const direction = col > zeroCol ? 1 : -1;
                for (let i = zeroCol; i !== col; i += direction) {
                    numberList[row][i] = numberList[row][i + direction];
                }
                numberList[row][col] = 0;
                zeroCol = col;
            } else {
                const direction = row > zeroRow ? 1 : -1;
                for (let i = zeroRow; i !== row; i += direction) {
                    numberList[i][col] = numberList[i + direction][col];
                }
                numberList[row][col] = 0;
                zeroRow = row;
            }

            if (oldZeroRow !== zeroRow || oldZeroCol !== zeroCol) {
                moves++;
                document.getElementById('moves').textContent = moves;
            }

            renderGame();
        }

        // 渲染华容道
        function renderGame() {
            const game = document.getElementById("game");
            const items = game.querySelectorAll('.game_item');
            
            items.forEach(item => {
                const row = parseInt(item.getAttribute('row'));
                const col = parseInt(item.getAttribute('col'));
                item.innerText = numberList[row][col] === 0 ? "" : numberList[row][col];
            });
        }

        // 打乱华容道
        function chaos() {
            isShuffling = true;
            const rCount = Math.floor(Math.random() * 50 + 50);
            for(let i = 0; i <= rCount; i++) {
                const rRow = Math.floor(Math.random() * 4);
                const rCol = Math.floor(Math.random() * 4);
                zeroRun(rRow, rCol);
            }
            isShuffling = false;
        }

        // 添加事件监听
        document.getElementById("game").addEventListener("click", function(e) {
            let clickedItem = e.target;
            if (!clickedItem.hasAttribute("row")) {
                clickedItem = clickedItem.closest(".game_item");
            }
            
            if (clickedItem && clickedItem.className === "game_item") {
                const row = parseInt(clickedItem.getAttribute("row"));
                const col = parseInt(clickedItem.getAttribute("col"));
                
                if (row === zeroRow || col === zeroCol) {
                    zeroRun(row, col);
                }
            }
        });

        // 添加键盘控制
        document.onkeydown = function(e) {
            switch(e.code) {
                case "ArrowUp":
                    if (zeroRow === 3) return;
                    zeroRun(zeroRow + 1, zeroCol);
                    break;
                case "ArrowDown":
                    if (zeroRow === 0) return;
                    zeroRun(zeroRow - 1, zeroCol);
                    break;
                case "ArrowLeft":
                    if (zeroCol === 3) return;
                    zeroRun(zeroRow, zeroCol + 1);
                    break;
                case "ArrowRight":
                    if (zeroCol === 0) return;
                    zeroRun(zeroRow, zeroCol - 1);
                    break;
            }
        }

        // 添加窗口大小变化时重新计算位置的处理
        window.addEventListener('resize', function() {
            // 添加防抖处理
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                initializeMazePieces();
            }, 250);
        });

        // 修改 CSS 样式，添加过渡效果
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .game_item {
                transition: opacity 0.3s ease;
            }
        `;
        document.head.appendChild(styleElement);
    </script>
</body>
</html> 