<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>一举两得</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            background: linear-gradient(135deg, #e8f4f8, #d1e9f5);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px 0;
            box-sizing: border-box;
        }

        .header {
            width: 100%;
            background: linear-gradient(135deg, #4a90e2, #67a6e5);
            color: white;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
            margin-bottom: 20px;
        }

        .header h1 {
            margin: 0;
            font-size: 28px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            justify-content: center;
            width: 100%;
            max-width: 408px;
            padding: 0 15px 15px;
            box-sizing: border-box;
            gap: 15px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            color: white;
            flex: 1;
            max-width: 120px;
            font-weight: 500;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.15);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-new {
            background: linear-gradient(135deg, #34ace0, #63cdff);
        }

        .btn-exit {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .btn-solve {
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
        }

        .stats {
            background-color: white;
            padding: 15px 30px;
            border-radius: 20px;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.1);
            margin: 0 0 20px;
            display: flex;
            gap: 40px;
            min-width: 300px;
            justify-content: center;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8fa6;
            margin-bottom: 5px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a90e2;
            font-family: monospace;
            min-width: 100px;
            text-align: center;
        }

        .container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 1100px;
            margin: 0 auto;
            gap: 20px;
        }

        #game, #mirror-maze {
            width: 520px;
            height: 520px;
            position: relative;
            overflow: visible;
        }

        #game canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .maze-piece {
            position: absolute;
            width: 90px;
            height: 90px;
            background: white;
            z-index: 0;
            margin: 2px;
        }

        #drawing-board {
            width: 408px;
            height: 408px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            cursor: crosshair;
        }

        .game_item {
            position: absolute;
            z-index: 3;
            border-radius: 0;
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
            color: white;
            text-align: center;
            cursor: pointer;
            user-select: none;
            font-weight: bold;
            transition: transform 0.2s ease;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game_item:empty {
            background: transparent;
            box-shadow: none;
            pointer-events: none;
            opacity: 0;
        }

        .game_item {
            z-index: 3;
        }

        @media (max-width: 480px) {
            body {
                padding: 10px 0;
            }

            .header h1 {
                font-size: 24px;
            }

            .controls {
                padding: 0 10px 10px;
            }

            .btn {
                padding: 10px 15px;
                font-size: 14px;
            }

            .stats {
                padding: 12px 20px;
                gap: 30px;
            }

            .container, #game {
                width: 380px;
            }
            
            #game {
                height: 380px;
                padding: 20px;
            }
            
            .maze-piece {
                width: 75px;
                height: 75px;
            }
            
            .game_item {
                height: 65px;
                width: 65px;
                line-height: 65px;
                font-size: 18px;
                margin: 2px;
            }
        }

        .firework-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            bottom: 0;
            animation: launch 1s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
        }

        @keyframes launch {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-60vh);
            }
        }

        @keyframes explode {
            0% {
                transform: translate(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }

        .game_item {
            transition: opacity 0.3s ease;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
            }
            
            #game, #mirror-maze {
                margin-bottom: 20px;
            }
        }

        #mirror-maze {
            position: relative;
            overflow: hidden;
        }

        #mirror-maze canvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .controls {
            gap: 10px;
            flex-wrap: wrap;
            max-width: 500px;
        }

        .btn {
            min-width: 90px;
        }

        .maze-controls {
            position: absolute;
            top: 8px;
            right: 8px;
            display: flex;
            gap: 8px;
            z-index: 10;
        }

        .maze-controls .btn {
            padding: 6px 15px;
            font-size: 14px;
            min-width: 80px;
            height: 32px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
            border-radius: 4px;
            line-height: 1.2;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .maze-controls .btn:hover {
            opacity: 1;
            transform: translateY(-1px);
        }

        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: none;
        }

        .toast {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 16px;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            text-align: center;
            min-width: 200px;
            max-width: 80vw;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }

        .toast.error {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .toast.info {
            background: linear-gradient(135deg, #4a90e2, #67a6e5);
        }

        .mode-selector {
            display: flex;
            gap: 10px;
        }

        .btn-mode {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            opacity: 0.7;
        }

        .btn-mode.active {
            background: linear-gradient(135deg, #34ace0, #63cdff);
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>一举两得</h1>
    </div>

    <div class="controls">
        <button class="btn btn-exit" onclick="exitGame()">退出</button>
        <div class="mode-selector">
            <button class="btn btn-mode active" onclick="switchMode('novice')">新手模式</button>
            <button class="btn btn-mode" onclick="switchMode('expert')">专家模式</button>
        </div>
    </div>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-label">时间</span>
            <span class="stat-value" id="timer">00:00.000</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">步数</span>
            <span class="stat-value" id="moves">0</span>
        </div>
    </div>

    <div class="container">
        <div id="game">
            <!-- 迷宫和数字方块将在这里动态生成 -->
        </div>
        <div id="mirror-maze">
            <!-- 镜像迷宫将在这里动态生成 -->
        </div>
    </div>

    <div class="toast-container"></div>

    <script>
        const MAZE = {
            N: 1,  // 0001 - 北墙
            E: 2,  // 0010 - 东墙
            S: 4,  // 0100 - 南墙
            W: 8   // 1000 - 西墙
        };

        const MAZE_CONFIG = {
            wallThickness: 12,      
            columns: 8,            
            rows: 8,
            backgroundColor: '#ffffff',
            mazeColor: '#000000',
            solveColor: '#cc3737',
            startColor: '#ff6b6b',  
            endColor: '#34ace0',     
            canvasSize: 520,       // 画布大小
            margin: 60,            // 边距
        };

        // 修改统一的尺寸计算函数
        function calculateGameSizes() {
            const availableSize = MAZE_CONFIG.canvasSize - (MAZE_CONFIG.margin * 2);
            
            // 计算迷宫的尺寸（8x8网格）
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 修改：华容道方块大小计算需要考虑墙的厚度
            // 一个华容道方块对应两个迷宫格子加一个墙的厚度
            const blockSize = (cellSize * 2) + MAZE_CONFIG.wallThickness/4;
            
            // 华容道的总大小应该和迷宫内部区域一致
            const puzzleSize = cellSize * 8;
            
            // 计算偏移量使两个游戏居中
            const offsetX = Math.floor((MAZE_CONFIG.canvasSize - mazeSize) / 2);
            const offsetY = Math.floor((MAZE_CONFIG.canvasSize - mazeSize) / 2);
            
            // 华容道的起始位置
            const puzzleOffsetX = offsetX;
            const puzzleOffsetY = offsetY;
            
            return {
                cellSize,         // 迷宫格子大小
                mazeSize,         // 迷宫总大小
                blockSize,        // 华容道方块大小（已包含墙的厚度）
                puzzleSize,       // 华容道总大小
                offsetX,          // 迷宫X轴偏移量
                offsetY,          // 迷宫Y轴偏移量
                puzzleOffsetX,    // 华容道X轴偏移量
                puzzleOffsetY     // 华容道Y轴偏移量
            };
        }

        // 生成迷宫
        function generateMaze() {
            const width = 8;
            const height = 8;
            const maze = Array(height).fill().map(() => Array(width).fill(15)); // 15 = 所有墙
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            
            function carve(x, y) {
                visited[y][x] = true;
                
                // 定义四个方向：北、东、南、西
                const directions = [
                    [0, -1, MAZE.N],
                    [1, 0, MAZE.E],
                    [0, 1, MAZE.S],
                    [-1, 0, MAZE.W]
                ];
                
                // 随机打乱方向
                for (let i = directions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [directions[i], directions[j]] = [directions[j], directions[i]];
                }
                
                // 尝试每个方向
                for (const [dx, dy, direction] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (newX >= 0 && newX < width && newY >= 0 && newY < height && !visited[newY][newX]) {
                        // 移除当前单元格的墙
                        maze[y][x] &= ~direction;
                        
                        // 移除相邻单元格的对应墙
                        const opposite = {
                            [MAZE.N]: MAZE.S,
                            [MAZE.S]: MAZE.N,
                            [MAZE.E]: MAZE.W,
                            [MAZE.W]: MAZE.E
                        }[direction];
                        
                        maze[newY][newX] &= ~opposite;
                        
                        carve(newX, newY);
                    }
                }
            }
            
            // 从(0,0)开始生成迷宫
            carve(0, 0);
            
            // 确保入口和出口
            maze[0][0] &= ~MAZE.N;  // 移除口的北墙
            maze[height-1][width-1] &= ~MAZE.S;  // 移除出口的南墙
            
            return maze;
        }

        // 初始化迷宫
        function initializeMazePieces() {
            const game = document.getElementById('game');
            game.innerHTML = '';
            
            const canvas = document.createElement('canvas');
            canvas.width = MAZE_CONFIG.canvasSize;
            canvas.height = MAZE_CONFIG.canvasSize;
            const ctx = canvas.getContext('2d');
            
            // 生成迷宫
            currentMaze = generateMaze();
            
            // 计算所有尺寸
            const sizes = calculateGameSizes();
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 移动到绘制起点
            ctx.translate(sizes.offsetX, sizes.offsetY);
            
            // 绘制迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 先绘制外边框
            ctx.fillRect(0, 0, sizes.mazeSize, MAZE_CONFIG.wallThickness); // 上边框
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, sizes.mazeSize); // 左边框
            ctx.fillRect(sizes.mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, sizes.mazeSize); // 右边框
            ctx.fillRect(0, sizes.mazeSize - MAZE_CONFIG.wallThickness, sizes.mazeSize, MAZE_CONFIG.wallThickness); // 下边框
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * sizes.cellSize;
                    const py = y * sizes.cellSize;
                    
                    // 绘制北墙
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, sizes.cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制西墙
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, sizes.cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制东墙（最后一列）
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + sizes.cellSize, py, MAZE_CONFIG.wallThickness, sizes.cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // 绘制南墙（最后一行）
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + sizes.cellSize, sizes.cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, sizes.cellSize, MAZE_CONFIG.wallThickness); // 入口
            ctx.clearRect(sizes.mazeSize - sizes.cellSize - MAZE_CONFIG.wallThickness, 
                         sizes.mazeSize - MAZE_CONFIG.wallThickness, 
                         sizes.cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness); // 出口
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(sizes.cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(sizes.mazeSize - sizes.cellSize/2 - MAZE_CONFIG.wallThickness, 
                    sizes.mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            game.appendChild(canvas);
            
            // 取画布的实际渲染尺寸
            const canvasRect = canvas.getBoundingClientRect();
            const gameRect = game.getBoundingClientRect();
            
            // 计算画布相对于游戏容器的偏移
            const canvasOffsetX = canvasRect.left - gameRect.left;
            const canvasOffsetY = canvasRect.top - gameRect.top;
            
            // 计算华容道起始位置（使用之前声明的变量）
            const puzzleStartX = canvasOffsetX + sizes.offsetX - (MAZE_CONFIG.wallThickness / 2);
            const puzzleStartY = canvasOffsetY + sizes.offsetY - (MAZE_CONFIG.wallThickness / 2);

            // 清除现有的方块
            const existingItems = game.querySelectorAll('.game_item');
            existingItems.forEach(item => item.remove());

            // 使用新的函数创建华容道方块
            createPuzzlePieces(game, sizes);
            
            // 添加镜像迷宫的生成
            const mirrorMaze = document.getElementById('mirror-maze');
            mirrorMaze.innerHTML = '';
            
            const mirrorCanvas = document.createElement('canvas');
            mirrorCanvas.width = MAZE_CONFIG.canvasSize;
            mirrorCanvas.height = MAZE_CONFIG.canvasSize;
            const mirrorCtx = mirrorCanvas.getContext('2d');
            
            // 设置背景
            mirrorCtx.fillStyle = MAZE_CONFIG.backgroundColor;
            mirrorCtx.fillRect(0, 0, mirrorCanvas.width, mirrorCanvas.height);
            
            // 使用相同的计算方式，但使用不同的变量名
            const mirrorMargin = 60;
            const mirrorAvailableSize = Math.min(mirrorCanvas.width, mirrorCanvas.height) - (mirrorMargin * 2);
            const mirrorCellSize = Math.floor(mirrorAvailableSize / 8);
            const mirrorMazeSize = (mirrorCellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const mirrorOffsetX = Math.floor((mirrorCanvas.width - mirrorMazeSize) / 2);
            const mirrorOffsetY = Math.floor((mirrorCanvas.height - mirrorMazeSize) / 2);
            
            // 移动到绘制起点
            mirrorCtx.translate(mirrorOffsetX, mirrorOffsetY);
            
            // 在绘制镜像迷宫的外边框之前添加颜色设置
            mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 绘制镜像迷宫的外边框 - 不再清除入口和出口
            mirrorCtx.fillRect(0, 0, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 上边框 - 完整
            mirrorCtx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 左边框
            mirrorCtx.fillRect(mirrorMazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mirrorMazeSize); // 右边框
            mirrorCtx.fillRect(0, mirrorMazeSize - MAZE_CONFIG.wallThickness, mirrorMazeSize, MAZE_CONFIG.wallThickness); // 下边框 - 完整
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * mirrorCellSize;
                    const py = y * mirrorCellSize;
                    
                    // 对于镜像迷宫，始终绘制北墙和南墙
                    mirrorCtx.fillStyle = MAZE_CONFIG.mazeColor;
                    mirrorCtx.fillRect(px, py, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px, py + mirrorCellSize, mirrorCellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    
                    // 对于像迷宫，始终绘制东墙和西墙
                    mirrorCtx.fillRect(px, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                    mirrorCtx.fillRect(px + mirrorCellSize, py, MAZE_CONFIG.wallThickness, mirrorCellSize + MAZE_CONFIG.wallThickness);
                }
            }
            
            mirrorMaze.appendChild(mirrorCanvas);
        }

        // 页面加载时初始化迷宫
        window.onload = function() {
            currentMaze = generateMaze(); // 确保页面加载时就生成迷宫
            initializeMazePieces();
            updateMirrorMazeState();
        }

        // 新游戏按钮点击事件
        function startNewGame() {
            // 停止当前计时器
            stopTimer();
            isTimerStarted = false;
            document.getElementById('timer').textContent = '00:00.000';  // 更新初始显示格式
            
            // 重置游戏状态
            numberList = [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 0]
            ];
            zeroRow = 3;
            zeroCol = 3;
            
            // 重置步数
            moves = 0;
            document.getElementById('moves').textContent = '0';
            
            // 重置计时器显示
            document.getElementById('timer').textContent = '00:00.000';
            
            // 清除绘制的迷宫路径
            clearDrawing();
            
            // 重新生成迷宫和初始化方块
            currentMaze = generateMaze();
            initializeMazePieces();
            
            // 打乱方块
            chaos();
            
            // 重置华容道完成状态
            isPuzzleComplete = false;
            updateMirrorMazeState();
        }

        // 退出按钮点击事件
        function exitGame() {
            if (confirm('确定要退出游戏吗？')) {
                window.location.href = '/';
            }
        }

        // 修改寻路相关代码
        function findPath(maze) {
            const width = 8;
            const height = 8;
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const path = [];
            
            function canMove(fromX, fromY, toX, toY) {
                // 检查是否可以从一个格子移动到另一个格子
                if (toX < 0 || toX >= width || toY < 0 || toY >= height) {
                    return false;
                }
                
                // 检查两个格子之间是否有墙
                if (toX > fromX) { // 向东移动
                    return !(maze[fromY][fromX] & MAZE.E);
                } else if (toX < fromX) { // 向西移动
                    return !(maze[fromY][fromX] & MAZE.W);
                } else if (toY > fromY) { // 向南移动
                    return !(maze[fromY][fromX] & MAZE.S);
                } else if (toY < fromY) { // 向北移动
                    return !(maze[fromY][fromX] & MAZE.N);
                }
                return false;
            }
            
            function dfs(x, y) {
                if (x === width-1 && y === height-1) {
                    path.push([x, y]);
                    return true;
                }
                
                visited[y][x] = true;
                path.push([x, y]);
                
                // 定义四个方向的移动
                const moves = [
                    [0, -1], // 北
                    [1, 0],  // 东
                    [0, 1],  // 南
                    [-1, 0]  // 西
                ];
                
                // 随机打乱移动顺序，使路径更随机
                for (let i = moves.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [moves[i], moves[j]] = [moves[j], moves[i]];
                }
                
                for (const [dx, dy] of moves) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (!visited[newY]?.[newX] && canMove(x, y, newX, newY)) {
                        if (dfs(newX, newY)) {
                            return true;
                        }
                    }
                }
                
                path.pop();
                return false;
            }
            
            if (dfs(0, 0)) {
                return path;
            }
            return null;
        }

        // 添加验证迷宫答案的函数
        function validateMazeAnswer() {
            if (drawnLines.length === 0) {
                showToast('请先绘制迷宫答案', 'info');
                return false;
            }

            const userPath = convertLinesToPath(drawnLines);
            
            if (!isValidPath(userPath)) {
                showToast('路径必须从起点连接到终点', 'error');
                return false;
            }

            if (!isPathContinuous(userPath)) {
                showToast('路径必须是完整连续的，不能有断开的部分', 'error');
                return false;
            }

            if (isPathCrossingWalls(userPath, currentMaze)) {
                showToast('路径不能穿过墙壁', 'error');
                return false;
            }

            showToast('答案正确！', 'success');
            return true;
        }

        // 将线段转换为路径点
        function convertLinesToPath(lines) {
            const points = new Set();
            const sizes = calculateGameSizes();
            
            // 首先收集所有点
            lines.forEach(line => {
                const x1 = Math.floor((line.x1 - sizes.offsetX - MAZE_CONFIG.wallThickness) / sizes.cellSize);
                const y1 = Math.floor((line.y1 - sizes.offsetY - MAZE_CONFIG.wallThickness) / sizes.cellSize);
                const x2 = Math.floor((line.x2 - sizes.offsetX - MAZE_CONFIG.wallThickness) / sizes.cellSize);
                const y2 = Math.floor((line.y2 - sizes.offsetY - MAZE_CONFIG.wallThickness) / sizes.cellSize);
                
                if (line.isHorizontal) {
                    for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
                        points.add(`${x},${y1}`);
                    }
                } else {
                    for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
                        points.add(`${x1},${y}`);
                    }
                }
            });
            
            // 将点集合转换为数组
            return Array.from(points).map(point => {
                const [x, y] = point.split(',').map(Number);
                return {x, y};
            });
        }

        // 验证路径是否从起点到终点
        function isValidPath(path) {
            const hasStart = path.some(p => p.x === 0 && p.y === 0);
            const hasEnd = path.some(p => p.x === 7 && p.y === 7);
            return hasStart && hasEnd;
        }

        // 修改验证路径连续性的函数
        function isPathContinuous(path) {
            // 首先找到起点（应该是 0,0）
            const startPoint = path.find(p => p.x === 0 && p.y === 0);
            if (!startPoint) return false;

            // 创建已访问点的集合
            const visited = new Set([`${startPoint.x},${startPoint.y}`]);
            // 创建待访问的点队列，从起点开始
            const queue = [startPoint];
            
            // 使用广度优先搜索检查路径的连续性
            while (queue.length > 0) {
                const current = queue.shift();
                
                // 检查四个方向的相邻点
                const directions = [
                    {dx: 0, dy: -1}, // 上
                    {dx: 1, dy: 0},  // 右
                    {dx: 0, dy: 1},  // 下
                    {dx: -1, dy: 0}  // 左
                ];
                
                for (const {dx, dy} of directions) {
                    const nextX = current.x + dx;
                    const nextY = current.y + dy;
                    const key = `${nextX},${nextY}`;
                    
                    // 检查这个点是否在路径中且未访问过
                    const nextPoint = path.find(p => p.x === nextX && p.y === nextY);
                    if (nextPoint && !visited.has(key)) {
                        visited.add(key);
                        queue.push(nextPoint);
                    }
                }
            }
            
            // 检查是否所有路径点都被访问到了
            return path.every(p => visited.has(`${p.x},${p.y}`));
        }

        // 验证路径是否穿墙
        function isPathCrossingWalls(path, maze) {
            for (let i = 1; i < path.length; i++) {
                const current = path[i-1];
                const next = path[i];
                
                // 检查两点之间是否有墙
                if (next.x > current.x && (maze[current.y][current.x] & MAZE.E)) return true; // 向东移动
                if (next.x < current.x && (maze[current.y][current.x] & MAZE.W)) return true; // 向西移动
                if (next.y > current.y && (maze[current.y][current.x] & MAZE.S)) return true; // 向南移动
                if (next.y < current.y && (maze[current.y][current.x] & MAZE.N)) return true; // 向北移动
            }
            return false;
        }

        // 修改 solveMaze 函数
        function solveMaze() {
            // 先验证用户的答案
            if (!validateMazeAnswer()) {
                return;
            }
            
            // 答案正确，显示解法
            // 停止计时器
            stopTimer();
            isTimerStarted = false;

            if (!currentMaze) {
                console.error('No maze available');
                return;
            }
            
            // 完全隐藏华容道方块
            const gameItems = document.querySelectorAll('.game_item');
            gameItems.forEach(item => {
                item.style.display = 'none';
            });
            
            const game = document.getElementById('game');
            const canvas = game.querySelector('canvas');
            const ctx = canvas.getContext('2d');
            
            // 获取当前画布的变换状态
            const currentTransform = ctx.getTransform();
            
            // 清除画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 设置背景
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 使用当前的变换状态
            ctx.setTransform(currentTransform);
            
            // 绘迷宫墙壁
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // 使用与初始化时相同的尺
            const margin = 60;
            const availableSize = Math.min(canvas.width, canvas.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 绘制外边框
            ctx.fillRect(0, 0, mazeSize, MAZE_CONFIG.wallThickness);
            ctx.fillRect(0, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(mazeSize - MAZE_CONFIG.wallThickness, 0, MAZE_CONFIG.wallThickness, mazeSize);
            ctx.fillRect(0, mazeSize - MAZE_CONFIG.wallThickness, mazeSize, MAZE_CONFIG.wallThickness);
            
            // 绘制内部墙壁
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (x === 7 || (cell & MAZE.E)) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    if (y === 7 || (cell & MAZE.S)) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // 清除入口和出口
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness);
            ctx.clearRect(mazeSize - cellSize - MAZE_CONFIG.wallThickness, 
                         mazeSize - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, 
                         MAZE_CONFIG.wallThickness);
            
            // 添加入口和出口标记
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeSize - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeSize - MAZE_CONFIG.wallThickness/2, 
                    MAZE_CONFIG.wallThickness, 0, Math.PI * 2);
            ctx.fill();
            
            // 获取并绘制解决路径
            const path = findPath(currentMaze);
            
            if (path && path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = MAZE_CONFIG.solveColor;
                ctx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                const [firstX, firstY] = path[0];
                ctx.moveTo(firstX * cellSize + cellSize/2, firstY * cellSize + cellSize/2);
                
                for (const [x, y] of path) {
                    ctx.lineTo(x * cellSize + cellSize/2, y * cellSize + cellSize/2);
                }
                
                ctx.stroke();
            }
            
            // 添加返回按钮
            const backButton = document.createElement('button');
            backButton.className = 'btn btn-new';
            backButton.style.position = 'absolute';
            backButton.style.top = '20px';
            backButton.style.right = '20px';
            backButton.innerText = '返回游戏';
            backButton.onclick = function() {
                backButton.remove();
                gameItems.forEach(item => {
                    item.style.display = 'flex';
                });
            };
            game.appendChild(backButton);
            
            // 在镜像迷宫上也显示解决路径
            const mirrorCanvas = document.querySelector('#mirror-maze canvas');
            if (mirrorCanvas) {
                const mirrorCtx = mirrorCanvas.getContext('2d');
                if (path && path.length > 0) {
                    mirrorCtx.beginPath();
                    mirrorCtx.strokeStyle = MAZE_CONFIG.solveColor;
                    mirrorCtx.lineWidth = MAZE_CONFIG.wallThickness / 2;
                    mirrorCtx.lineCap = 'round';
                    mirrorCtx.lineJoin = 'round';
                    
                    const [firstX, firstY] = path[0];
                    mirrorCtx.moveTo(firstX * mirrorCellSize + mirrorCellSize/2, firstY * mirrorCellSize + mirrorCellSize/2);
                    
                    for (const [x, y] of path) {
                        mirrorCtx.lineTo(x * mirrorCellSize + mirrorCellSize/2, y * mirrorCellSize + mirrorCellSize/2);
                    }
                    
                    mirrorCtx.stroke();
                }
            }
        }

        // 在全局作用域添加变量
        let currentMaze = null;

        // 初始布局
        let numberList = [
            [1, 2, 3, 4],
            [5, 6, 7, 8],
            [9, 10, 11, 12],
            [13, 14, 15, 0]
        ];
        let zeroRow = 3;
        let zeroCol = 3;
        let moves = 0;
        let timer;
        let startTime = 0;  // 添加开始时间变量
        let isShuffling = false;
        let isTimerStarted = false;  // 添加标记，记录计时器是否已启动

        // 添加华容道的移动逻辑
        function zeroRun(row, col) {
            if (row !== zeroRow && col !== zeroCol) {
                return;
            }
            
            if (numberList[row][col] === 0) {
                return;
            }

            // 第一次移动时启动计时器
            if (!isTimerStarted) {
                startTimer();
                isTimerStarted = true;
            }

            const oldZeroRow = zeroRow;
            const oldZeroCol = zeroCol;

            if (row === zeroRow) {
                const direction = col > zeroCol ? 1 : -1;
                for (let i = zeroCol; i !== col; i += direction) {
                    numberList[row][i] = numberList[row][i + direction];
                }
                numberList[row][col] = 0;
                zeroCol = col;
            } else {
                const direction = row > zeroRow ? 1 : -1;
                for (let i = zeroRow; i !== row; i += direction) {
                    numberList[i][col] = numberList[i + direction][col];
                }
                numberList[row][col] = 0;
                zeroRow = row;
            }

            if (oldZeroRow !== zeroRow || oldZeroCol !== zeroCol) {
                moves++;
                document.getElementById('moves').textContent = moves;
            }

            renderGame();

            if (gameMode === 'expert') {
                isPuzzleComplete = isPuzzleSolved();
                updateMirrorMazeState();
            }
        }

        // 渲染华容道
        function renderGame() {
            const game = document.getElementById("game");
            const items = game.querySelectorAll('.game_item');
            
            items.forEach(item => {
                const row = parseInt(item.getAttribute('row'));
                const col = parseInt(item.getAttribute('col'));
                item.innerText = numberList[row][col] === 0 ? "" : numberList[row][col];
            });
        }

        // 修改打乱华容道的函数
        function chaos() {
            isShuffling = true;
            const rCount = Math.floor(Math.random() * 50 + 50);
            
            // 保存当前步数
            const tempMoves = moves;
            
            for(let i = 0; i <= rCount; i++) {
                const rRow = Math.floor(Math.random() * 4);
                const rCol = Math.floor(Math.random() * 4);
                // 临时禁用计时器启动和步数计算
                const tempIsTimerStarted = isTimerStarted;
                isTimerStarted = true;  // 防止在打乱过程中启动计时器
                moves = tempMoves;      // 保持步数不变
                zeroRun(rRow, rCol);
                isTimerStarted = tempIsTimerStarted;
            }
            
            // 重置步数为0
            moves = 0;
            document.getElementById('moves').textContent = '0';
            
            isShuffling = false;
        }

        // 添加事件监听
        document.getElementById("game").addEventListener("click", function(e) {
            let clickedItem = e.target;
            if (!clickedItem.hasAttribute("row")) {
                clickedItem = clickedItem.closest(".game_item");
            }
            
            if (clickedItem && clickedItem.className === "game_item") {
                const row = parseInt(clickedItem.getAttribute("row"));
                const col = parseInt(clickedItem.getAttribute("col"));
                
                if (row === zeroRow || col === zeroCol) {
                    zeroRun(row, col);
                }
            }
        });

        // 添加键盘控制
        document.onkeydown = function(e) {
            switch(e.code) {
                case "ArrowUp":
                    if (zeroRow === 3) return;
                    zeroRun(zeroRow + 1, zeroCol);
                    break;
                case "ArrowDown":
                    if (zeroRow === 0) return;
                    zeroRun(zeroRow - 1, zeroCol);
                    break;
                case "ArrowLeft":
                    if (zeroCol === 3) return;
                    zeroRun(zeroRow, zeroCol + 1);
                    break;
                case "ArrowRight":
                    if (zeroCol === 0) return;
                    zeroRun(zeroRow, zeroCol - 1);
                    break;
            }
        }

        // 添加窗口大小变化时重新计算位置的处理
        window.addEventListener('resize', function() {
            // 添加防抖处理
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(function() {
                initializeMazePieces();
            }, 250);
        });

        // 修改 CSS 式，添加过渡效果
        const styleElement = document.createElement('style');
        styleElement.textContent = `
            .game_item {
                transition: opacity 0.3s ease;
            }
        `;
        document.head.appendChild(styleElement);

        // 添加新的变量
        let startX = 0;
        let startY = 0;
        let previewCtx = null;
        let previewCanvas = null;

        // 在 initializeDrawing 函数之前添加以下变量声明
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let drawingCtx = null;
        let drawingCanvas = null;

        // 修改 getCoordinates 函数
        function getCoordinates(e) {
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            // 使用与迷宫生成时完全相同的计算方式
            const margin = 60;
            const availableSize = Math.min(rect.width, rect.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((rect.width - mazeSize) / 2);
            const offsetY = Math.floor((rect.height - mazeSize) / 2);
            
            let clientX, clientY;
            if (e.type.includes('touch')) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // 计算相对于迷宫原点的坐标
            return [
                clientX - rect.left - offsetX,
                clientY - rect.top - offsetY
            ];
        }

        // 修改 getNearestCellCenter 函数
        function getNearestCellCenter(x, y) {
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            // 使用与迷宫生成时完全相同的计算方式
            const margin = 60;
            const availableSize = Math.min(rect.width, rect.height) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            // 计算居中偏移
            const offsetX = Math.floor((rect.width - mazeSize) / 2);
            const offsetY = Math.floor((rect.height - mazeSize) / 2);
            
            // 计算格子索引（考虑第一个格的度）
            const col = Math.floor((x - MAZE_CONFIG.wallThickness) / cellSize);
            const row = Math.floor((y - MAZE_CONFIG.wallThickness) / cellSize);
            
            // 确保索引在有效范围内
            const validCol = Math.max(0, Math.min(7, col));
            const validRow = Math.max(0, Math.min(7, row));
            
            // 计算子中心点坐标
            const centerX = validCol * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
            const centerY = validRow * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
            
            return {
                x: centerX + offsetX,
                y: centerY + offsetY,
                row: validRow,
                col: validCol
            };
        }

        // 添加一个变量来存储上一个绘制点
        let lastDrawnPoint = null;

        // 修改 startDrawing 函数
        function startDrawing(e) {
            if (gameMode === 'expert' && !isPuzzleComplete) {
                showToast('请先完成华容道谜题', 'info');
                return;
            }
            
            e.preventDefault();
            const coords = getCoordinates(e);
            const [x, y] = coords;
            const center = getNearestCellCenter(x, y);
            
            isDrawing = true;
            startX = center.x;
            startY = center.y;
            lastX = center.x;
            lastY = center.y;
            lastDrawnPoint = { x: center.x, y: center.y };
        }

        // 添加一个全局变量来存储所有绘制的线段
        let drawnLines = [];

        // 修改 finishDrawing 函数
        function finishDrawing(e) {
            if (!isDrawing) return;
            isDrawing = false;
            lastDrawnPoint = null;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }

        // 修改 handleDoubleClick 函数
        function handleDoubleClick(e) {
            const [x, y] = getCoordinates(e);
            const center = getNearestCellCenter(x, y);
            const clickX = center.x;
            const clickY = center.y;
            
            // 查找被点击的线段
            const clickedLineIndex = drawnLines.findIndex(line => {
                if (line.isHorizontal) {
                    // 水平线段：检查 Y 坐标是否匹配，以及 X 坐标是否在范围内
                    const minX = Math.min(line.x1, line.x2);
                    const maxX = Math.max(line.x1, line.x2);
                    return Math.abs(clickY - line.y1) <= MAZE_CONFIG.wallThickness &&
                           clickX >= minX - MAZE_CONFIG.wallThickness &&
                           clickX <= maxX + MAZE_CONFIG.wallThickness;
                } else {
                    // 垂直线段：检查 X 坐标是否匹配，以及 Y 坐标是否在范围内
                    const minY = Math.min(line.y1, line.y2);
                    const maxY = Math.max(line.y1, line.y2);
                    return Math.abs(clickX - line.x1) <= MAZE_CONFIG.wallThickness &&
                           clickY >= minY - MAZE_CONFIG.wallThickness &&
                           clickY <= maxY + MAZE_CONFIG.wallThickness;
                }
            });
            
            if (clickedLineIndex !== -1) {
                // 删除找到的线段
                drawnLines.splice(clickedLineIndex, 1);
                
                // 清除画布
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                
                // 重新绘制所有保留的线段
                drawnLines.forEach(line => {
                    drawingCtx.beginPath();
                    drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    drawingCtx.shadowBlur = 4;
                    drawingCtx.shadowOffsetX = 2;
                    drawingCtx.shadowOffsetY = 2;
                    drawingCtx.lineWidth = MAZE_CONFIG.wallThickness;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';
                    drawingCtx.strokeStyle = '#4a90e2';
                    
                    drawingCtx.moveTo(line.x1, line.y1);
                    drawingCtx.lineTo(line.x2, line.y2);
                    drawingCtx.stroke();
                });
                
                // 最后重新绘制所有心点
                drawCellCenters();
            }
        }

        // 修改 clearDrawing 函数
        function clearDrawing() {
            if (drawingCtx) {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawCellCenters();
                // 清空线段数组
                drawnLines = [];
            }
            
            if (previewCtx) {
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            }
        }

        // 修改 drawCellCenters 函数
        function drawCellCenters() {
            if (!drawingCtx) return;
            
            const mirrorMaze = document.getElementById('mirror-maze');
            const rect = mirrorMaze.getBoundingClientRect();
            
            const margin = 60;
            const availableSize = Math.min(520, 520) - (margin * 2);
            const cellSize = Math.floor(availableSize / 8);
            const mazeSize = (cellSize * 8) + MAZE_CONFIG.wallThickness;
            
            const offsetX = Math.floor((520 - mazeSize) / 2);
            const offsetY = Math.floor((520 - mazeSize) / 2);
            
            // 遍历所有格子
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const centerX = x * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
                    const centerY = y * cellSize + cellSize / 2 + MAZE_CONFIG.wallThickness;
                    
                    // 使用统一的样式绘制中心点
                    drawingCtx.beginPath();
                    drawingCtx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                    drawingCtx.arc(centerX + offsetX, centerY + offsetY, 2, 0, Math.PI * 2);
                    drawingCtx.fill();
                }
            }
        }

        // 修改计时器启动函数
        function startTimer() {
            startTime = Date.now();  // 记录开始时间
            document.getElementById('timer').textContent = '00:00.000';
            timer = setInterval(function() {
                const currentTime = Date.now();
                const elapsedTime = currentTime - startTime;
                
                // 计算分钟、秒和毫秒
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                const milliseconds = elapsedTime % 1000;
                
                // 格式化显示
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }, 10);  // 每10毫秒更新一次显示
        }

        // 修改计时器停止函数
        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
                
                // 记录最终时间
                const finalTime = Date.now() - startTime;
                const minutes = Math.floor(finalTime / 60000);
                const seconds = Math.floor((finalTime % 60000) / 1000);
                const milliseconds = finalTime % 1000;
                
                // 更新显示最终时间
                document.getElementById('timer').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
            }
        }

        // 修改 initializeMazePieces 函数在末尾添加：
        const originalInitializeMazePieces = initializeMazePieces;
        initializeMazePieces = function() {
            originalInitializeMazePieces();
            clearDrawing();
            initializeDrawing();
        }

        // 修改控制按钮区域，添加清除绘图按钮
        const controlsDiv = document.querySelector('.controls');
        const clearButton = document.createElement('button');
        clearButton.className = 'btn btn-new';
        clearButton.innerText = '清除绘图';
        clearButton.onclick = clearDrawing;
        controlsDiv.appendChild(clearButton);

        // 页面加载完成后初始化绘图功能
        window.addEventListener('load', initializeDrawing);

        // 添加初始化绘图功能函数
        function initializeDrawing() {
            const mirrorMaze = document.getElementById('mirror-maze');
            
            // 创建绘图层
            drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = MAZE_CONFIG.canvasSize;
            drawingCanvas.height = MAZE_CONFIG.canvasSize;
            drawingCanvas.style.position = 'absolute';
            drawingCanvas.style.top = '0';
            drawingCanvas.style.left = '0';
            drawingCanvas.style.pointerEvents = 'all';
            drawingCanvas.style.cursor = 'crosshair';
            drawingCtx = drawingCanvas.getContext('2d');
            
            // 创建预览层
            previewCanvas = document.createElement('canvas');
            previewCanvas.width = MAZE_CONFIG.canvasSize;
            previewCanvas.height = MAZE_CONFIG.canvasSize;
            previewCanvas.style.position = 'absolute';
            previewCanvas.style.top = '0';
            previewCanvas.style.left = '0';
            previewCanvas.style.pointerEvents = 'none';
            previewCtx = previewCanvas.getContext('2d');
            
            // 创建控制按钮容器
            const mazeControls = document.createElement('div');
            mazeControls.className = 'maze-controls';
            
            // 创建新游戏按钮
            const newGameButton = document.createElement('button');
            newGameButton.className = 'btn btn-new';
            newGameButton.innerText = '新游戏';
            newGameButton.onclick = startNewGame;
            
            // 创建提交答案按钮
            const solveButton = document.createElement('button');
            solveButton.className = 'btn btn-solve';
            solveButton.innerText = '提交答案';
            solveButton.onclick = solveMaze;
            
            // 创建清除绘图按钮
            const clearButton = document.createElement('button');
            clearButton.className = 'btn btn-new';
            clearButton.innerText = '清除绘图';
            clearButton.onclick = clearDrawing;
            
            // 添加按钮到控制容器
            mazeControls.appendChild(newGameButton);
            mazeControls.appendChild(solveButton);
            mazeControls.appendChild(clearButton);
            
            // 添加所有元素到镜像迷宫
            mirrorMaze.appendChild(drawingCanvas);
            mirrorMaze.appendChild(previewCanvas);
            mirrorMaze.appendChild(mazeControls);
            
            // 立即绘制中心点
            drawCellCenters();
            
            // 添加事件监听器
            drawingCanvas.addEventListener('mousedown', startDrawing);
            drawingCanvas.addEventListener('mousemove', showPreview);
            drawingCanvas.addEventListener('mouseup', finishDrawing);
            drawingCanvas.addEventListener('mouseout', cancelDrawing);
            
            // 触摸设备支持
            drawingCanvas.addEventListener('touchstart', handleTouchStart);
            drawingCanvas.addEventListener('touchmove', handleTouchMove);
            drawingCanvas.addEventListener('touchend', finishDrawing);
            
            // 添加双击事件监听
            drawingCanvas.addEventListener('dblclick', handleDoubleClick);
        }

        // 添加取消绘制函数
        function cancelDrawing() {
            if (!isDrawing) return;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            isDrawing = false;
        }

        // 添加触摸事件处理函数
        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            startDrawing(mouseEvent);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            showPreview(mouseEvent);
        }

        // 修改 showPreview 函数
        function showPreview(e) {
            if (!isDrawing) return;
            
            const [x, y] = getCoordinates(e);
            const center = getNearestCellCenter(x, y);
            const currentX = center.x;
            const currentY = center.y;
            
            // 如果移动到新的格子中心点
            if (currentX !== lastX || currentY !== lastY) {
                // 检查是否可以画线（水平或垂直）
                const dx = Math.abs(currentX - lastX);
                const dy = Math.abs(currentY - lastY);
                
                if (dx === 0 || dy === 0) { // 只允许水平或垂直线
                    // 绘制实际的线段
                    const line = {
                        x1: lastX,
                        y1: lastY,
                        x2: currentX,
                        y2: currentY,
                        isHorizontal: dx > dy
                    };
                    drawnLines.push(line);
                    
                    drawingCtx.beginPath();
                    drawingCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                    drawingCtx.shadowBlur = 4;
                    drawingCtx.shadowOffsetX = 2;
                    drawingCtx.shadowOffsetY = 2;
                    drawingCtx.lineWidth = MAZE_CONFIG.wallThickness;
                    drawingCtx.lineCap = 'round';
                    drawingCtx.lineJoin = 'round';
                    drawingCtx.strokeStyle = '#4a90e2';
                    
                    drawingCtx.moveTo(line.x1, line.y1);
                    drawingCtx.lineTo(line.x2, line.y2);
                    drawingCtx.stroke();
                    
                    // 更新最后的位置
                    lastX = currentX;
                    lastY = currentY;
                }
            }
            
            // 清除之前的预览
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // 绘制预览线
            const dx = Math.abs(currentX - lastX);
            const dy = Math.abs(currentY - lastY);
            
            if (dx === 0 || dy === 0) { // 只显示水平或垂直的预览线
                previewCtx.beginPath();
                previewCtx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                previewCtx.shadowBlur = 4;
                previewCtx.shadowOffsetX = 2;
                previewCtx.shadowOffsetY = 2;
                previewCtx.lineWidth = MAZE_CONFIG.wallThickness;
                previewCtx.lineCap = 'round';
                previewCtx.lineJoin = 'round';
                previewCtx.strokeStyle = '#4a90e2';
                previewCtx.globalAlpha = 0.7;
                
                previewCtx.moveTo(lastX, lastY);
                previewCtx.lineTo(currentX, currentY);
                previewCtx.stroke();
            }
        }

        // 修改 createPuzzlePieces 函数中的方块大小计算
        function createPuzzlePieces(game, sizes) {
            // 清除现有的方块
            const existingItems = game.querySelectorAll('.game_item');
            existingItems.forEach(item => item.remove());

            // 创建新的方块
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const gameItem = document.createElement("div");
                    gameItem.className = "game_item";
                    numberList[i][j] === 0 ? gameItem.innerText = "" : gameItem.innerText = numberList[i][j];
                    gameItem.setAttribute("row", i);
                    gameItem.setAttribute("col", j);
                    
                    // 计算方块位置（考虑墙的厚度累积）
                    const left = sizes.puzzleOffsetX + (j * sizes.blockSize);
                    const top = sizes.puzzleOffsetY + (i * sizes.blockSize);
                    
                    // 使用已经计算好的包含墙厚的方块大小
                    gameItem.style.left = left + 'px';
                    gameItem.style.top = top + 'px';
                    gameItem.style.width = sizes.blockSize + 'px';
                    gameItem.style.height = sizes.blockSize + 'px';
                    gameItem.style.lineHeight = sizes.blockSize + 'px';
                    gameItem.style.fontSize = Math.floor(sizes.blockSize * 0.4) + 'px';
                    
                    // 添加点击事件
                    gameItem.addEventListener('click', function() {
                        const row = parseInt(this.getAttribute('row'));
                        const col = parseInt(this.getAttribute('col'));
                        zeroRun(row, col);
                    });
                    
                    game.appendChild(gameItem);
                }
            }
        }

        // 添加显示提示的函数
        function showToast(message, type = 'error', duration = 3000) {
            const container = document.querySelector('.toast-container');
            
            // 创建提示元素
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            // 添加到容器
            container.appendChild(toast);
            
            // 触发重排以启动动画
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);
            
            // 设置自动消失
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    container.removeChild(toast);
                }, 300);
            }, duration);
        }

        // 添加游戏模式变量
        let gameMode = 'novice'; // 默认新手模式
        let isPuzzleComplete = false; // 华容道是否完成

        // 切换游戏模式
        function switchMode(mode) {
            gameMode = mode;
            // 更新按钮状态
            document.querySelectorAll('.btn-mode').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(mode === 'novice' ? '新手' : '专家')) {
                    btn.classList.add('active');
                }
            });
            
            // 重新开始游戏
            startNewGame();
        }

        // 检查华容道是否完成
        function isPuzzleSolved() {
            let count = 1;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (i === 3 && j === 3) {
                        if (numberList[i][j] !== 0) return false;
                    } else {
                        if (numberList[i][j] !== count++) return false;
                    }
                }
            }
            return true;
        }

        // 更新镜像迷宫状态
        function updateMirrorMazeState() {
            const mirrorMaze = document.getElementById('mirror-maze');
            if (gameMode === 'expert') {
                // 只在专家模式下控制是否可以绘制
                if (isPuzzleComplete) {
                    mirrorMaze.style.pointerEvents = 'auto';
                } else {
                    mirrorMaze.style.pointerEvents = 'none';
                }
            } else {
                mirrorMaze.style.pointerEvents = 'auto';
            }
        }
    </script>
</body>
</html> 