<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title><%= title %></title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            background-color: #e8f4f8;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .header {
            width: 100%;
            background: linear-gradient(135deg, #4a90e2, #67a6e5);
            color: white;
            padding: 12px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 408px;
            padding: 15px;
            box-sizing: border-box;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            color: white;
            flex: 1;
            max-width: 150px;
            font-weight: 500;
        }

        .btn-new {
            background: linear-gradient(135deg, #34ace0, #63cdff);
        }

        .btn-exit {
            background: linear-gradient(135deg, #ff6b6b, #ff8e8e);
        }

        .btn-solve {
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
        }

        .stats {
            background-color: white;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            margin: 10px 0;
            display: flex;
            gap: 20px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label {
            font-size: 14px;
            color: #7f8fa6;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #4a90e2;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 408px;
            margin: 0 auto;
        }

        #game {
            width: 408px;
            height: 408px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            padding: 0;
            box-sizing: border-box;
            position: relative;
            overflow: hidden;
        }

        .maze-piece {
            position: absolute;
            width: 90px;
            height: 90px;
            background: white;
            z-index: 0;
            margin: 2px;
        }

        #drawing-board {
            width: 408px;
            height: 408px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 15px rgba(74, 144, 226, 0.1);
            cursor: crosshair;
        }

        .game_item {
            position: relative;
            z-index: 1;
            border-radius: 8px;
            background: linear-gradient(135deg, #67a6e5, #4a90e2);
            color: white;
            text-align: center;
            cursor: pointer;
            user-select: none;
            font-size: 24px;
            font-weight: bold;
            transition: transform 0.2s ease;
            box-sizing: border-box;
        }

        .game_item:empty {
            background: transparent;
            box-shadow: none;
            pointer-events: none;
        }

        @media (max-width: 480px) {
            .container, #game, #drawing-board {
                width: 300px;
            }
            
            #game, #drawing-board {
                height: 300px;
            }
            
            .maze-piece {
                width: 75px;
                height: 75px;
            }
            
            .game_item {
                height: 65px;
                width: 65px;
                line-height: 65px;
                font-size: 18px;
                margin: 2px;
            }
        }

        .firework-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 999;
            overflow: hidden;
        }

        .firework {
            position: absolute;
            bottom: 0;
            animation: launch 1s ease-out forwards;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: explode 1s ease-out forwards;
        }

        @keyframes launch {
            0% {
                transform: translateY(0);
            }
            100% {
                transform: translateY(-60vh);
            }
        }

        @keyframes explode {
            0% {
                transform: translate(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>æ•°å­—åå®¹é“</h1>
    </div>

    <div class="controls">
        <button class="btn btn-exit" onclick="exitGame()">é€€å‡º</button>
        <button class="btn btn-new" onclick="startNewGame()">æ–°æ¸¸æˆ</button>
        <button class="btn btn-solve" onclick="solveMaze()">æ˜¾ç¤ºè§£æ³•</button>
    </div>

    <div class="stats">
        <div class="stat-item">
            <span class="stat-label">æ—¶é—´</span>
            <span class="stat-value" id="timer">00:00</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">æ­¥æ•°</span>
            <span class="stat-value" id="moves">0</span>
        </div>
    </div>

    <div class="container">
        <div id="game">
            <!-- è¿·å®«å’Œæ•°å­—æ–¹å—å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
        </div>
    </div>

    <script>
        //åˆå§‹å¸ƒå±€
        var numberList = [[1, 2, 3, 4],
                        [5, 6, 7, 8],
                        [9, 10, 11, 12],
                        [13, 14, 15, 0]];
        //0æ‰€å¤„çš„ä½ç½®
        var zeroRow = 3;
        var zeroCol = 3;
        let moves = 0;
        let timer;
        let seconds = 0;
        let isShuffling = false;
        let currentMaze = null;

        // è¿·å®«ç›¸å…³å¸¸é‡å®šä¹‰
        const MAZE = {
            N: 1,  // 0001 - åŒ—å¢™
            E: 2,  // 0010 - ä¸œå¢™
            S: 4,  // 0100 - å—å¢™
            W: 8   // 1000 - è¥¿å¢™
        };

        // ä¿®æ”¹è¿·å®«é…ç½®
        const MAZE_CONFIG = {
            wallThickness: 2,       // å¢™çš„åšåº¦
            columns: 8,            // 8x8ç½‘æ ¼
            rows: 8,
            backgroundColor: '#ffffff',
            mazeColor: '#000000',
            solveColor: '#cc3737',
            startColor: '#ff6b6b',  // å…¥å£é¢œè‰²
            endColor: '#34ace0'     // å‡ºå£é¢œè‰²
        };

        function updateTimer() {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            document.getElementById('timer').textContent = 
                `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
            seconds++;
        }

        function startTimer() {
            if (timer) clearInterval(timer);
            seconds = 0;
            timer = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            clearInterval(timer);
        }

        function updateMoves() {
            moves++;
            document.getElementById('moves').textContent = moves;
        }

        function startNewGame() {
            moves = 0;
            document.getElementById('moves').textContent = '0';
            // é‡ç½®åˆå§‹å¸ƒå±€
            numberList = [[1, 2, 3, 4],
                        [5, 6, 7, 8],
                        [9, 10, 11, 12],
                        [13, 14, 15, 0]];
            zeroRow = 3;
            zeroCol = 3;
            
            // é‡æ–°åˆå§‹åŒ–è¿·å®«å’Œæ•°å­—æ–¹å—
            const gameDiv = document.getElementById("game");
            gameDiv.innerHTML = ''; // æ¸…ç©ºæ‰€æœ‰å†…å®¹
            initializeMazePieces(); // é‡æ–°åˆå§‹åŒ–è¿·å®«å’Œæ–¹å—
            
            // æ‰“ä¹±æ•°å­—æ–¹å—
            chaos();
            
            // åœ¨æ‰“ä¹±ä¹‹åå¯åŠ¨è®¡æ—¶å™¨
            startTimer();
        }

        function exitGame() {
            if (confirm('ç¡®å®šè¦é€€å‡ºæ¸¸æˆå—ï¼Ÿ')) {
                window.location.href = '/';
            }
        }

        //æ‰“ä¹±çš„å‡½æ•°
        function chaos() {
            isShuffling = true;  // å¼€å§‹æ‰“ä¹±
            //éšæœºå¾ªç¯æ¬¡æ•°å–[50, 100)
            var rCount = Math.floor(Math.random() * 50 + 50);
            for(let i = 0; i <= rCount; i++) {
                //éšæœºå‡º0å°†è¦å»çš„ä½ç½®
                let rRow = Math.floor(Math.random() * 4);
                let rCol = Math.floor(Math.random() * 4);
                zeroRun(rRow, rCol);
            }
            
            // å¦‚æœæ‰“ä¹±åæ°å¥½æ˜¯èƒœåˆ©çŠ¶æ€ï¼Œåˆ™å†æ¬¡æ‰“ä¹±
            if (win()) {
                chaos();
                return;
            }
            isShuffling = false;  // æ‰“ä¹±ç»“æŸ
        }

        function zeroRun(row, col) {
            // å¦‚æœåœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—ï¼Œç›´æ¥è¿”å›
            if (row !== zeroRow && col !== zeroCol) {
                return;
            }
            
            //ç§»åŠ¨ä½ç½®ä¸å˜çš„è¯ï¼Œç›´æ¥return
            if (numberList[row][col] === 0) {
                return;
            }

            // è®°å½•ç§»åŠ¨å‰çš„ä½ç½®
            const oldZeroRow = zeroRow;
            const oldZeroCol = zeroCol;

            //0ç§»åŠ¨åˆ°æŒ‡å®šä½ç½®ï¼ˆæ¨ªåæ ‡ï¼‰
            if (row === zeroRow) {
                // æ°´å¹³ç§»åŠ¨
                const direction = col > zeroCol ? 1 : -1;
                for (let i = zeroCol; i !== col; i += direction) {
                    numberList[row][i] = numberList[row][i + direction];
                }
                numberList[row][col] = 0;
                zeroCol = col;
            } else {
                // å‚ç›´ç§»åŠ¨
                const direction = row > zeroRow ? 1 : -1;
                for (let i = zeroRow; i !== row; i += direction) {
                    numberList[i][col] = numberList[i + direction][col];
                }
                numberList[row][col] = 0;
                zeroRow = row;
            }

            // å¦‚æœç¡®å®å‘ç”Ÿäº†ç§»åŠ¨ï¼Œæ›´æ–°æ­¥æ•°
            if (oldZeroRow !== zeroRow || oldZeroCol !== zeroCol) {
                updateMoves();
            }

            renderGame();

            //åˆ¤æ˜¯å¦èƒœåˆ©ï¼ˆåªåœ¨éæ‰“ä¹±çŠ¶æ€ä¸‹åˆ¤æ–­ï¼‰
            if (!isShuffling && win()) {
                stopTimer();
                setTimeout(() => {
                    createFireworks();
                }, 100);
            }
        }

        function renderGame() {
            const gameDiv = document.getElementById("game");
            // ä¿å­˜è¿·å®«èƒŒæ™¯
            const mazeBackground = gameDiv.querySelector('canvas').parentElement;
            // æ¸…ç©ºå…¶ä»–å†…å®¹
            gameDiv.innerHTML = '';
            // é‡æ–°æ·»åŠ è¿·å®«èƒŒæ™¯
            gameDiv.appendChild(mazeBackground);
            
            // é‡æ–°æ·»åŠ æ•°å­—æ–¹å—
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const gameItem = document.createElement("div");
                    gameItem.className = "game_item";
                    //å¦‚æœä¸º0çš„è¯ï¼Œä¸æ˜¾ç¤ºæ•°å­—
                    numberList[i][j] === 0 ? gameItem.innerText = "" : gameItem.innerText = numberList[i][j];
                    gameItem.setAttribute("row", i);
                    gameItem.setAttribute("col", j);
                    gameDiv.appendChild(gameItem);
                }
            }
        }

        //åˆ¤æ–­èƒœåˆ©
        function win() {
            // æ­£ç¡®çš„æ•°å­—åºåˆ—åº”è¯¥æ˜¯ 1-15 æŒ‰é¡ºåºæ’åˆ—ï¼Œæœ€åæ˜¯0
            const correctSequence = [
                [1, 2, 3, 4],
                [5, 6, 7, 8],
                [9, 10, 11, 12],
                [13, 14, 15, 0]
            ];
            
            // æ£€æŸ¥æ¯ä¸ªä½ç½®çš„æ•°å­—æ˜¯å¦æ­£ç¡®
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    if (numberList[i][j] !== correctSequence[i][j]) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ç›‘å¬ç”¨æˆ·ç‚¹å‡»äº‹ä»¶
        document.getElementById("game").addEventListener("click", function(e) {
            // è·å–è¢«ç‚¹å‡»çš„å…ƒç´ 
            let clickedItem = e.target;
            
            // å¦‚æœç‚¹å‡»çš„æ˜¯æ•°å­—å—å†…çš„æ–‡æœ¬ï¼Œåˆ™è·å–çˆ¶å…ƒç´ 
            if (!clickedItem.hasAttribute("row")) {
                clickedItem = clickedItem.closest(".game_item");
            }
            
            if (clickedItem && clickedItem.className === "game_item") {
                let row = parseInt(clickedItem.getAttribute("row"));
                let col = parseInt(clickedItem.getAttribute("col"));
                
                // æ£€æŸ¥ç‚¹å‡»çš„ä½ç½®æ˜¯å¦åœ¨ç©ºæ ¼çš„åŒä¸€è¡Œæˆ–åŒä¸€
                if (row === zeroRow || col === zeroCol) {
                    zeroRun(row, col);
                }
            }
        });

        // ç›‘å¬ç”¨æˆ·é”®ç›˜äº‹ä»¶
        document.onkeydown = function(e) {
            switch(e.code) {
                case "ArrowUp":
                    if (zeroRow === 3) return;
                    zeroRun(zeroRow + 1, zeroCol);
                    break;
                case "ArrowDown":
                    if (zeroRow === 0) return;
                    zeroRun(zeroRow - 1, zeroCol);
                    break;
                case "ArrowLeft":
                    if (zeroCol === 3) return;
                    zeroRun(zeroRow, zeroCol + 1);
                    break;
                case "ArrowRight":
                    if (zeroCol === 0) return;
                    zeroRun(zeroRow, zeroCol - 1);
                    break;
                default: 
                    break;
            }
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        startNewGame();

        function createFireworks() {
            const container = document.createElement('div');
            container.className = 'firework-container';
            document.body.appendChild(container);

            // åˆ›å»ºå¤šä¸ªçƒŸèŠ±
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    createSingleFirework(container);
                }, i * 300); // æ¯éš”300mså‘å°„ä¸€ä¸ªçƒŸèŠ±
            }

            // ç¤ºè·èƒœä¿¡æ¯
            const message = document.createElement('div');
            message.style.position = 'fixed';
            message.style.top = '50%';
            message.style.left = '50%';
            message.style.transform = 'translate(-50%, -50%)';
            message.style.background = 'rgba(255, 255, 255, 0.95)';
            message.style.padding = '20px';
            message.style.borderRadius = '10px';
            message.style.boxShadow = '0 0 20px rgba(0,0,0,0.2)';
            message.style.zIndex = '1000';
            message.style.textAlign = 'center';
            message.innerHTML = `
                <h2 style="color: #4a90e2; margin: 0 0 10px 0; font-size: 24px;">ğŸ‰ æ­å–œä½ èµ¢äº†ï¼ğŸ‰</h2>
                <p style="margin: 5px 0; font-size: 18px;">ç”¨æ—¶: ${document.getElementById('timer').textContent}</p>
                <p style="margin: 5px 0; font-size: 18px;">æ­¥æ•°: ${moves}</p>
            `;
            document.body.appendChild(message);

            // 6ç§’åç§»é™¤çƒŸèŠ±å’Œæ¶ˆæ¯
            setTimeout(() => {
                container.remove();
                message.remove();
            }, 6000);
        }

        function createSingleFirework(container) {
            const firework = document.createElement('div');
            firework.className = 'firework';
            firework.style.left = Math.random() * 100 + 'vw';
            container.appendChild(firework);

            // çƒŸèŠ±é¢œè‰²
            const colors = [
                '#ff0000', '#00ff00', '#0000ff', '#ffff00', 
                '#ff00ff', '#00ffff', '#ff9900', '#ff0099'
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];

            // çƒŸèŠ±çˆ†ç‚¸
            setTimeout(() => {
                firework.remove();
                createParticles(container, firework.offsetLeft, firework.offsetTop, color);
            }, 1000);
        }

        function createParticles(container, x, y, color) {
            // åˆ›å»ºå¤šä¸ªç²’å­
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.backgroundColor = color;

                // éšæœºæ–¹å‘å’Œè·ç¦»
                const angle = (Math.random() * Math.PI * 2);
                const velocity = Math.random() * 200 + 100;
                const tx = Math.cos(angle) * velocity;
                const ty = Math.sin(angle) * velocity;
                
                particle.style.setProperty('--tx', `${tx}px`);
                particle.style.setProperty('--ty', `${ty}px`);
                
                container.appendChild(particle);

                // 1ç§’åç§»é™¤ç²’å­
                setTimeout(() => particle.remove(), 1000);
            }
        }

        // è¿·å®«ç”Ÿæˆç›¸å…³ä»£ç 
        function generateMaze() {
            const width = 8;  // æ”¹ä¸º8x8
            const height = 8;
            const maze = Array(height).fill().map(() => Array(width).fill(15));
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            
            function removeWall(x, y, dir) {
                // ç§»é™¤å½“å‰å•å…ƒæ ¼çš„å¢™
                maze[y][x] &= ~dir;
                // ç§»é™¤ç›¸é‚»å•å…ƒæ ¼çš„å¯¹åº”å¢™
                const [nx, ny] = getNextPosition(x, y, dir);
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    maze[ny][nx] &= ~getOppositeWall(dir);
                }
            }
            
            function getNextPosition(x, y, dir) {
                switch(dir) {
                    case MAZE.N: return [x, y-1];
                    case MAZE.E: return [x+1, y];
                    case MAZE.S: return [x, y+1];
                    case MAZE.W: return [x-1, y];
                }
            }
            
            function getOppositeWall(dir) {
                switch(dir) {
                    case MAZE.N: return MAZE.S;
                    case MAZE.E: return MAZE.W;
                    case MAZE.S: return MAZE.N;
                    case MAZE.W: return MAZE.E;
                }
            }
            
            function getUnvisitedNeighbors(x, y) {
                const neighbors = [];
                const directions = [MAZE.N, MAZE.E, MAZE.S, MAZE.W];
                
                for (const dir of directions) {
                    const [nx, ny] = getNextPosition(x, y, dir);
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                        neighbors.push({x: nx, y: ny, dir: dir});
                    }
                }
                
                return neighbors;
            }
            
            function carve(x, y) {
                visited[y][x] = true;
                
                // è·å–æœªè®¿é—®çš„é‚»å±…å¹¶éšæœºæ‰“ä¹±é¡ºåº
                let neighbors = getUnvisitedNeighbors(x, y);
                neighbors.sort(() => Math.random() - 0.5);
                
                for (const next of neighbors) {
                    if (!visited[next.y][next.x]) {
                        removeWall(x, y, next.dir);
                        carve(next.x, next.y);
                    }
                }
            }
            
            // ä»(0,0)å¼€å§‹ç”Ÿæˆè¿·å®«
            carve(0, 0);
            
            // æ·»åŠ å…¥å£å’Œå‡ºå£
            maze[0][0] &= ~MAZE.N;  // å…¥å£åœ¨å·¦ä¸Šè§’
            maze[height-1][width-1] &= ~MAZE.S;  // å‡ºå£åœ¨å³ä¸‹è§’
            
            return maze;
        }

        function initializeMazePieces() {
            const game = document.getElementById('game');
            
            const mazeBackground = document.createElement('div');
            mazeBackground.style.position = 'absolute';
            mazeBackground.style.top = '0';
            mazeBackground.style.left = '0';
            mazeBackground.style.width = '408px';
            mazeBackground.style.height = '408px';
            mazeBackground.style.zIndex = '0';
            
            const canvas = document.createElement('canvas');
            canvas.width = 408;
            canvas.height = 408;
            const ctx = canvas.getContext('2d');
            
            currentMaze = generateMaze();
            
            // è®¾ç½®èƒŒæ™¯
            ctx.fillStyle = MAZE_CONFIG.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // è®¡ç®—è¿·å®«çš„å®é™…å¤§å°ï¼Œç•™å‡ºè¶³å¤Ÿç©ºé—´æ˜¾ç¤ºæ‰€æœ‰å¢™å£
            const margin = 10;
            const availableWidth = canvas.width - (margin * 2);
            const availableHeight = canvas.height - (margin * 2);
            const cellSize = Math.min(
                Math.floor((availableWidth - MAZE_CONFIG.wallThickness) / 8),
                Math.floor((availableHeight - MAZE_CONFIG.wallThickness) / 8)
            );
            const mazeWidth = cellSize * 8 + MAZE_CONFIG.wallThickness; // åŠ ä¸Šæœ€åä¸€ä¸ªå¢™çš„å®½åº¦
            const mazeHeight = cellSize * 8 + MAZE_CONFIG.wallThickness; // åŠ ä¸Šæœ€åä¸€ä¸ªå¢™çš„é«˜åº¦
            
            // è®¡ç®—åå®¹é“æ–¹å—çš„å¤§å°ï¼ˆ2x2ä¸ªè¿·å®«å•å…ƒæ ¼ï¼‰
            const blockSize = cellSize * 2;
            
            // è®¡ç®—å±…ä¸­åç§»
            const offsetX = (canvas.width - mazeWidth) / 2;
            const offsetY = (canvas.height - mazeHeight) / 2;
            
            // ç§»åŠ¨ç»˜åˆ¶èµ·ç‚¹ä»¥å±…ä¸­è¿·å®«
            ctx.translate(offsetX, offsetY);
            
            // ç»˜åˆ¶è¿·å®«å¢™å£
            ctx.fillStyle = MAZE_CONFIG.mazeColor;
            
            // ç»˜åˆ¶æ‰€æœ‰å¢™å£
            for(let y = 0; y < 8; y++) {
                for(let x = 0; x < 8; x++) {
                    const cell = currentMaze[y][x];
                    const px = x * cellSize;
                    const py = y * cellSize;
                    
                    // ç»˜åˆ¶åŒ—å¢™
                    if (cell & MAZE.N) {
                        ctx.fillRect(px, py, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                    
                    // ç»˜åˆ¶è¥¿å¢™
                    if (cell & MAZE.W) {
                        ctx.fillRect(px, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // ç»˜åˆ¶ä¸œå¢™ï¼ˆåŒ…æ‹¬æœ€åä¸€åˆ—ï¼‰
                    if (cell & MAZE.E || x === 7) {
                        ctx.fillRect(px + cellSize, py, MAZE_CONFIG.wallThickness, cellSize + MAZE_CONFIG.wallThickness);
                    }
                    
                    // ç»˜åˆ¶å—å¢™ï¼ˆåŒ…æ‹¬æœ€åä¸€è¡Œï¼‰
                    if (cell & MAZE.S || y === 7) {
                        ctx.fillRect(px, py + cellSize, cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness);
                    }
                }
            }
            
            // æ¸…é™¤å…¥å£å’Œå‡ºå£çš„å¢™
            ctx.clearRect(0, 0, cellSize, MAZE_CONFIG.wallThickness); // å…¥å£
            ctx.clearRect(mazeWidth - cellSize - MAZE_CONFIG.wallThickness, mazeHeight - MAZE_CONFIG.wallThickness, 
                         cellSize + MAZE_CONFIG.wallThickness, MAZE_CONFIG.wallThickness); // å‡ºå£
            
            // æ·»åŠ å…¥å£å’Œå‡ºå£æ ‡è®°
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.startColor;
            ctx.arc(cellSize/2, MAZE_CONFIG.wallThickness/2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.fillStyle = MAZE_CONFIG.endColor;
            ctx.arc(mazeWidth - cellSize/2 - MAZE_CONFIG.wallThickness, 
                    mazeHeight - MAZE_CONFIG.wallThickness/2, 4, 0, Math.PI * 2);
            ctx.fill();
            
            mazeBackground.appendChild(canvas);
            game.appendChild(mazeBackground);
            
            // ä¿®æ”¹æ•°å­—æ–¹å—çš„æ·»åŠ éƒ¨åˆ†
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    const gameItem = document.createElement("div");
                    gameItem.className = "game_item";
                    numberList[i][j] === 0 ? gameItem.innerText = "" : gameItem.innerText = numberList[i][j];
                    gameItem.setAttribute("row", i);
                    gameItem.setAttribute("col", j);
                    gameItem.style.position = 'absolute';
                    gameItem.style.left = (offsetX + j * blockSize) + 'px';
                    gameItem.style.top = (offsetY + i * blockSize) + 'px';
                    gameItem.style.width = (blockSize - 4) + 'px'; // å‡å»é—´éš™
                    gameItem.style.height = (blockSize - 4) + 'px'; // å‡å»é—´éš™
                    gameItem.style.lineHeight = (blockSize - 4) + 'px';
                    gameItem.style.margin = '2px'; // æ·»åŠ é—´éš™
                    game.appendChild(gameItem);
                }
            }
        }

        // ä¿®æ”¹ window.onload å‡½æ•°
        window.onload = function() {
            // ç§»é™¤ initializeDrawingBoard çš„è°ƒç”¨ï¼Œå› ä¸ºæˆ‘ä»¬ä¸å†éœ€è¦ä¸‹æ–¹çš„ç”»æ¿
            initializeMazePieces();
            startNewGame();
        }

        // ä¿®æ”¹ solveMaze å‡½æ•°ï¼Œè®©å®ƒåœ¨æ¸¸æˆåŒºåŸŸæ˜¾ç¤ºè§£å†³è·¯å¾„
        function solveMaze() {
            if (!currentMaze) return;

            const game = document.getElementById('game');
            const canvas = game.querySelector('canvas');
            const ctx = canvas.getContext('2d');

            const path = findPath(currentMaze);
            
            if (path) {
                ctx.beginPath();
                ctx.strokeStyle = '#cc3737';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                
                const cellSize = canvas.width / 8;
                
                // ç§»åŠ¨åˆ°èµ·ç‚¹ä¸­å¿ƒ
                ctx.moveTo(cellSize/2, 0);
                
                // ç»˜åˆ¶è·¯å¾„
                for (let i = 0; i < path.length; i++) {
                    const [x, y] = path[i];
                    ctx.lineTo(
                        x * cellSize + cellSize/2,
                        y * cellSize + cellSize/2
                    );
                }
                
                // è¿æ¥åˆ°ç»ˆç‚¹
                ctx.lineTo(
                    7 * cellSize + cellSize/2,
                    canvas.height
                );
                
                ctx.stroke();
            }
        }

        function findPath(maze) {
            const width = 8;   // æ”¹ä¸º8x8
            const height = 8;
            const visited = Array(height).fill().map(() => Array(width).fill(false));
            const path = [];
            
            function canMove(fromX, fromY, toX, toY) {
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä»ä¸€ä¸ªæ ¼å­ç§»åŠ¨åˆ°å¦ä¸€ä¸ªæ ¼å­
                if (toX < 0 || toX >= width || toY < 0 || toY >= height) {
                    return false;
                }
                
                // æ£€æŸ¥å¢™çš„æ–¹å‘
                if (toX > fromX) { // å‘ä¸œç§»åŠ¨
                    return !(maze[fromY][fromX] & MAZE.E);
                } else if (toX < fromX) { // å‘è¥¿ç§»åŠ¨
                    return !(maze[fromY][fromX] & MAZE.W);
                } else if (toY > fromY) { // å‘å—ç§»åŠ¨
                    return !(maze[fromY][fromX] & MAZE.S);
                } else if (toY < fromY) { // å‘åŒ—ç§»åŠ¨
                    return !(maze[fromY][fromX] & MAZE.N);
                }
                return false;
            }
            
            function dfs(x, y) {
                if (x === 7 && y === 7) {
                    path.push([x, y]);
                    return true;
                }
                
                visited[y][x] = true;
                
                // å®šä¹‰å››ä¸ªæ–¹å‘ï¼šåŒ—ã€ä¸œã€å—ã€è¥¿
                const directions = [
                    [0, -1], // åŒ—
                    [1, 0],  // ä¸œ
                    [0, 1],  // å—
                    [-1, 0]  // è¥¿
                ];
                
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (!visited[newY]?.[newX] && canMove(x, y, newX, newY)) {
                        path.push([x, y]);
                        if (dfs(newX, newY)) {
                            return true;
                        }
                        path.pop();
                    }
                }
                
                visited[y][x] = false;
                return false;
            }
            
            // ä»èµ·ç‚¹å¼€å§‹æœç´¢
            if (dfs(0, 0)) {
                return path;
            }
            return null;
        }
    </script>
</body>
</html> 